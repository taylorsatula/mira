{
  "_rubric": {
    "Categories": {
      "Code Organization & Cleanup": "Tasks related to code organization, file structure, and removing unnecessary code",
      "Config Management & System Architecture": "Tasks related to configuration management, system architecture, and foundational infrastructure",
      "Tool Management & Functionality": "Tasks related to tool enabling/disabling, interaction between tools, and core functionality",
      "Memory & Context Management": "Tasks related to conversation history, context windows, and message processing",
      "Performance Optimizations": "Tasks related to improving speed, efficiency, and resource usage",
      "Feature Implementations": "Tasks related to adding new features or expanding existing functionality",
      "User Experience & Interface": "Tasks related to improving user interaction and interface elements"
    },
    "Task Types": {
      "Question": "Requires investigation or research to understand or resolve",
      "Quick Fix": "Simple changes that can be implemented quickly with minimal risk",
      "Systemic Issue": "Requires understanding but not major restructuring",
      "Major Refactor": "Significant code reorganization affecting multiple components"
    },
    "Priority Guidelines": {
      "High": "Critical for system stability, security, or core functionality",
      "Medium": "Important for improved functionality or developer experience",
      "Low": "Nice-to-have improvements or stylistic changes"
    }
  },
  "Code Organization & Cleanup": {
    "Questions": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We aren't really using the docs/ folder. Are there markdown files that would be better suited to being in that directory vs where they currently are?",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION do we still need stimulus.py? It hasn't been updated in a long time. Are there other ways to interact with our application (outside the flask api) or is the file fine as-is?",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION Is crud.py worth keeping in the application? Are the abilities it contains used often enough that it isn't worth just hardcoding them in-place.",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "f\"because no hash changes were detected\") #ANNOTATION when would this happen in practice?",
        "isfixed": false,
        "context": "This appears in _load_tool_examples when checking if synthetic example generation should be skipped. Developer wants clarification on when hash detection would prevent regenerating examples."
      }
    ],
    "Quick Fixes": [
      {
        "filename": "find_annotations.py",
        "annotation": "\"\"\"Find all #ANNOTATION or # ANNOTATION comments in code files.",
        "isfixed": false,
        "context": "This is the docstring of a script that searches for annotation comments throughout the codebase."
      }
    ]
  },
  "Config Management & System Architecture": {
    "Questions": [
      {
        "filename": "config/config_manager.py",
        "annotation": "from config.config import ( #ANNOTATION is there a reliable way to query what is in the config itself to dynamically load these? My thought is that after we realize our goal of having it so that you can drop a tool into tools/ and it works automagically next load adding and removing tools from this line will become a single manual step.",
        "isfixed": false,
        "context": "Developer is asking about automatically importing config classes from config.py without manually listing them in the import statement."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "model: Optional pre-loaded SentenceTransformer model to use (for sharing) #ANNOTATION <-- \"for sharing\"? Sharing what?",
        "isfixed": false,
        "context": "In the WorkflowManager constructor, developer is questioning the comment about 'sharing' the SentenceTransformer model."
      },
      {
        "filename": "config/config_manager.py",
        "annotation": "@property #ANNOTATION why do all of these need to be redundantly specified? Is there a good reason? Can't we just look for things that should have had an environmental variable and crash out if none is specified or a non-empty-string default is not given? Like,, if we don't have an Anthropic key we aren't getting off the ground but if we don't have a Square key that tool just won't work. This would also reduce our dependance on having to update a bunch of code sections when adding new tools or w/e.",
        "isfixed": false,
        "context": "Developer is questioning the need for individual environment variable property accessors in config_manager.py and suggesting a more dynamic approach."
      },
      {
        "filename": "config/config_manager.py",
        "annotation": "# Create a config instance with default values, overridden by environment variables #ANNOTATION does this leak environmental details? Can someone theoretically snatch the environmental variables from here or no?",
        "isfixed": false,
        "context": "Developer is concerned about potential security issues with config initialization exposing environment variables."
      },
      {
        "filename": "main.py",
        "annotation": "os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\" #ANNOTATION Is this the most appropriate place for this declaration?",
        "isfixed": false,
        "context": "Developer is questioning if setting TOKENIZERS_PARALLELISM environment variable at the beginning of main.py is the right location."
      },
      {
        "filename": "config/config_manager.py",
        "annotation": "# Try to parse value as JSON for complex types #ANNOTATION are there complex types? What is the usecase for this?",
        "isfixed": false,
        "context": "In config_manager.py, developer is questioning what complex types would be parsed from JSON in environment variables."
      },
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "self.model.half()  # Convert to fp16 first (may help with quantization) #ANNOTATION I see errors during startup in this step. Is this correctly coded?",
        "isfixed": false,
        "context": "Developer is reporting errors when the SentenceTransformer model is converted to half precision (fp16) during startup."
      }
    ],
    "Quick Fixes": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "model: Optional pre-loaded SentenceTransformer model to use (for sharing) #ANNOTATION - The SentenceTransformer should not be optional. ToolRelevanceEngine doesn't work without it.",
        "isfixed": false,
        "context": "In the ToolRelevanceEngine constructor, developer is pointing out that the model parameter should be required, not optional."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "# Use provided model or load a new one if not provided #ANNOTATION This is redundant. The SentenceTransformer is always available or else the whole application has critical game-breaking issues",
        "isfixed": false,
        "context": "Developer is suggesting that the fallback model loading is redundant since the application would fail earlier without it."
      },
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "# Use the shared embedding model if available #ANNOTATION Operate under the assumption that the embedding model is always available.",
        "isfixed": false,
        "context": "Similar concern about unnecessary conditional checks for the embedding model which should always be available."
      },
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "error_code=ErrorCode.UNKNOWN_ERROR, #ANNOTATION this is a perfect example of why we need to update errors.py",
        "isfixed": false,
        "context": "Developer wants more specific error codes rather than using UNKNOWN_ERROR."
      }
    ],
    "Systemic Issues": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION Now that the codebase is built out way more than it was last time we edited errors.py I think it is high time to create more descriptive error codes that cover our current implementation usecase.",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We need to review db.py and determine if it can/should be refactored to be more flexible or if its better to let sleeping dogs lie.",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "def _calculate_file_hash(self, file_path: str) -> str: #ANNOTATION We should create one global file hash checker function and use it throughout the codebase instead of each python file handling its own hashing function.",
        "isfixed": false,
        "context": "Developer notes that there are duplicate file hashing functions across multiple files that could be consolidated into a global utility."
      }
    ],
    "Major Refactors": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We should implement a multi-file config setup with config parameters being appended to the main config.py (at startup so that we can always reference a unified \"config\" object). Stay in config.py: SystemConfig, ToolRelevanceConfig, DatabaseConfig, ToolConfig, ConversationConfig, PathConfig, ApiConfig. Move to tool_config.py: EmailConfig, CalendarConfig, SquareConfig, GoogleMapsConfig.",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "config/config_manager.py",
        "annotation": "class AppConfig(BaseModel): #ANNOTATION Same goes for AppConfig. I'd like to be able to dynamically load the tools that exist in tools/ and unless specified in a manual field (within this file) all tools start with a predictable default_factory",
        "isfixed": false,
        "context": "Developer wants to make AppConfig automatically discover and include tool configurations rather than manually defining each one."
      }
    ]
  },
  "Tool Management & Functionality": {
    "Questions": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "# Don't disable any tools with the empty list - use explicitly defined empty list [] #ANNOTATION what does this mean?",
        "isfixed": false,
        "context": "Developer is confused about a comment regarding empty lists for disabling tools in the manage_tool_relevance method."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "# Disable all workflow tools before clearing workflow state #ANNOTATION I worry that this could cause the next message after a canceled workflow to have access to no tools. Please investigate if the workflow tool wipe happens BEFORE or AFTER the message analysis that enables tools in normal conversation.",
        "isfixed": false,
        "context": "Developer is concerned about a potential issue where canceling a workflow might leave the user without any enabled tools."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "# Disable all workflow tools before clearing workflow state #ANNOTATION",
        "isfixed": false,
        "context": "This appears to be an incomplete annotation - developer might have had the same concern as in line 456."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "# Then, enable each tool needed for this step #ANNOTATION does this attempt to reload tools that are already in tools_for_current_step?",
        "isfixed": false,
        "context": "Developer is questioning whether the workflow manager might redundantly try to enable tools that are already enabled."
      },
      {
        "filename": "tools/tool_feedback.py",
        "annotation": "def get_feedback_summary() -> Dict[str, Any]: #ANNOTATION <- Question: Where is this used outside this file?",
        "isfixed": false,
        "context": "Developer is asking if the get_feedback_summary function is actually used anywhere in the codebase."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "message_norm = np.linalg.norm(message_embedding) #ANNOTATION explain this normalizing process to me and tell me why it is necessary.",
        "isfixed": false,
        "context": "Developer needs explanation of vector normalization in the workflow detection method and why it's needed for proper cosine similarity calculation."
      },
      {
        "filename": "conversation.py",
        "annotation": "self.llm_bridge = llm_bridge or LLMBridge() #ANNOTATION why do we need llm_bridge or LLMBridge() shouldn't one or the other work?",
        "isfixed": false,
        "context": "Developer is questioning the pattern of accepting a parameter or creating a default instance if not provided."
      },
      {
        "filename": "conversation.py",
        "annotation": "self.tool_repo = tool_repo or ToolRepository() #ANNOTATION same goes for this one. Am I missing something?",
        "isfixed": false,
        "context": "Similar question about the pattern of accepting a parameter or creating a default instance if not provided."
      },
      {
        "filename": "main.py",
        "annotation": "original_generate_response = llm_bridge.generate_response #ANNOTATION what is 'original_generate_response? Is this a backwards compatibility thing?'",
        "isfixed": false,
        "context": "Developer is asking about the purpose of storing the original method reference before applying a decorator for token tracking."
      }
    ],
    "Systemic Issues": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "def _enable_tools(self, tools_to_enable: List[str]) -> List[str]: #ANNOTATION this appears to be a private method for enabling tools. Why not use a globally available enable/disable functionality?",
        "isfixed": false,
        "context": "Developer is questioning why there's a private method for enabling tools in ToolRelevanceEngine rather than a globally available function."
      },
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "def _disable_irrelevant_tools(self, current_relevant_tools: List[str]) -> None: #ANNOTATION same goes for this private method. Why not have them globally available? Is there something special that these ones need to be private?",
        "isfixed": false,
        "context": "Similar question about the private method for disabling tools in ToolRelevanceEngine."
      },
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "def enable_relevant_tools(self, message: str) -> List[str]: #ANNOTATION as the comment below says this appears to be left behind for backwards compatibility. Do we need it anymore? Is there a better unified solution we can use?",
        "isfixed": false,
        "context": "Developer is questioning if a method marked for backward compatibility is still needed or can be removed."
      }
    ],
    "Major Refactors": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION tool_finder.py used to be a standalone tool that could be called in conversation but that is no longer its role. Now it needs to transition to a programmatically called tool when <tool_needed /> is returned",
        "isfixed": false,
        "context": ""
      }
    ]
  },
  "Memory & Context Management": {
    "Questions": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "self.message_history: deque[str] = deque(maxlen=self.context_window_size) #ANNOTATION If we aren't using the whole context window to determine do we need to keep track of the full conversation history and/or is there any performance hit to this?",
        "isfixed": false,
        "context": "Developer is questioning if tracking the full conversation history in a deque has performance implications if it's not fully utilized."
      },
      {
        "filename": "conversation.py",
        "annotation": "self.logger.warning(f\"Skipping message with invalid role: {message.role}\") #ANNOTATION Directly above it says it converts all messages into user or assistant, no?",
        "isfixed": false,
        "context": "Developer is noting a contradiction - earlier code converts invalid roles to 'user', but this code skips messages with invalid roles."
      },
      {
        "filename": "conversation.py",
        "annotation": "stream: Whether to stream the response (default: False) #ANNOTATION I thought that stream /was/ enabled by default. Am I wrong?",
        "isfixed": false,
        "context": "Developer is questioning whether streaming responses is enabled by default or not."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "def to_json(self) -> str: #ANNOTATION shouldn't to_json and from_json be created and used at a global level? I could be wrong though.",
        "isfixed": false,
        "context": "Developer suggests standardizing JSON serialization/deserialization functions across the codebase rather than implementing them in each class."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "def from_json(self, json_str: str) -> None: #ANNOTATION same goes for this one",
        "isfixed": false,
        "context": "Same concern about standardizing JSON deserialization functions."
      }
    ],
    "Quick Fixes": [
      {
        "filename": "conversation.py",
        "annotation": "role = \"user\"  # For backwards compatibility, convert invalid roles to 'user' #ANNOTATION Throw a warning",
        "isfixed": false,
        "context": "Developer suggests adding a warning when converting invalid roles to 'user' for clarity."
      }
    ],
    "Systemic Issues": [
      {
        "filename": "conversation.py",
        "annotation": "# Continue processing responses until no more tool calls are made #ANNOTATION Shouldn't we be using the official Anthropic stop_reason = tool_use? This edit may go past tool responses",
        "isfixed": false,
        "context": "Developer suggests using Anthropic's official stop_reason instead of custom tool call detection logic."
      },
      {
        "filename": "conversation.py",
        "annotation": "enhanced_system_prompt = time_info + self.user_info + self.system_prompt #ANNOTATION This is kinda where I mean when I say we should have a centralized method for adding and removing data from the system prompt mid-conversation.",
        "isfixed": false,
        "context": "Developer wants a more flexible way to modify the system prompt during the conversation."
      }
    ],
    "Major Refactors": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We need to implement caching for previous messages. Theres no reason to not cache them. On that note I'd like to explore ways to cache parts of the system message. Some of it will change regularly (via checklists and reminders etc) but the core system message and user info should rarely if ever change mid-stream.",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "conversation.py",
        "annotation": "# Prune history if needed #ANNOTATION We should keep a complete conversation history stored somewhere outside the context window so that when the conversation is complete and saves we can go through it.",
        "isfixed": false,
        "context": "Developer suggests storing the complete conversation history separately from the context window."
      },
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We need to add anthropic.beta.messages with the Anthropic SDK. Once it is complete we need to add token-efficient-tools-2025-02-19 header to our messages.",
        "isfixed": false,
        "context": ""
      }
    ]
  },
  "Performance Optimizations": {
    "Questions": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "examples_per_temp=20,  # Initial value, will be adjusted based on complexity #ANNOTATION so why is this a value if its just going to change midstream?",
        "isfixed": false,
        "context": "Developer is questioning why examples_per_temp is hardcoded if it's going to be adjusted dynamically."
      }
    ],
    "Quick Fixes": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "skip_llm_review=False,  # Keep LLM review for quality control #ANNOTATION The llm review should not be an optional step",
        "isfixed": false,
        "context": "Developer suggests making LLM review a required step rather than configurable."
      }
    ],
    "Systemic Issues": [
      {
        "filename": "tool_relevance_engine.py",
        "annotation": "generator = SyntheticDataGenerator( #ANNOTATION these values should be in the ToolRelevanceEngine config",
        "isfixed": false,
        "context": "Developer suggests moving SyntheticDataGenerator configuration values to the config file instead of hardcoding."
      }
    ]
  },
  "Feature Implementations": {
    "Questions": [
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "start_match = re.search(r'<\\s*workflow_start:(\\w+)\\s* />', message) #ANNOTATION this used to be called \"<!--\\s*START_WORKFLOW:(\\w+)\\s*-->\" but I edited it manually and don't know where else in the codebase I need to edit",
        "isfixed": false,
        "context": "Developer changed the regex for workflow start markers but is unsure if other places in the codebase need to be updated."
      }
    ],
    "Quick Fixes": [
      {
        "filename": "onload_checker.py",
        "annotation": "three_days_later = today + timedelta(days=3) #ANNOTATION Lookahead X days should be able to be specified in the config",
        "isfixed": false,
        "context": "Developer suggests making the reminder lookup window configurable rather than hardcoded to 3 days."
      },
      {
        "filename": "onload_checker.py",
        "annotation": "end_date=three_days_later.strftime(\"%Y-%m-%d\") #ANNOTATION If we're updating it to not be a fixed amount of future days we should update this name",
        "isfixed": false,
        "context": "Developer suggests renaming the variable if the fixed 3-day window becomes configurable."
      },
      {
        "filename": "conversation.py",
        "annotation": "Args: #ANNOTATION Every one of these should be required and fail loudly if it doesn't have one.",
        "isfixed": false,
        "context": "Developer suggests making constructor parameters required rather than optional with defaults."
      }
    ],
    "Systemic Issues": [
      {
        "filename": "onload_checker.py",
        "annotation": "class OnLoadChecker: #ANNOTATION I've noticed that though I can ask questions against the onload text it doesn't have the right amount of hidden detail. For example if there is a notification I can't say \"Check the first one completed\" even if reminder_tool successfully activates.",
        "isfixed": false,
        "context": "Developer reports that notifications don't contain enough details to take subsequent actions on them."
      },
      {
        "filename": "onload_checker.py",
        "annotation": "def check_reminders(self) -> List[Stimulus]: #ANNOTATION we should have a section for overdue reminders and add them to the system message so Mira hassles the user to complete them during the conversation",
        "isfixed": false,
        "context": "Developer suggests adding overdue reminders to the system message for continuous reminding during conversations."
      },
      {
        "filename": "onload_checker.py",
        "annotation": "#ANNOTATION As mentioned in the other annotation we should have the ability to add overdue reminders to the system message so Mira can continuously hassle us to complete them during the conversation",
        "isfixed": false,
        "context": "Repeating the suggestion to add overdue reminders to the system message."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "def start_workflow(self, workflow_id: str) -> Dict[str, Any]: #ANNOTATION Recently I have experienced an issue where MIRA (incorrectly) guesses on what the name of the workflow. We should either improve the prompt that gives direction on how to pick a workflow ID ~or~ build in a programmatic matcher. I think option 1 would be better.",
        "isfixed": false,
        "context": "Developer reports an issue where MIRA incorrectly identifies workflow IDs and suggests improving either the prompt or adding a matcher."
      }
    ],
    "Major Refactors": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We should implement a \"manpage\" for tools. Sending a message that says \"man tool_name\" should trigger a comprehensive output on what xyz tool can do and example usecases both standalone and combined.",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We need a way for MIRA to act on files. It should be able to create, edit, and delete text files (we could use this for future workflows)",
        "isfixed": false,
        "context": ""
      },
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION We need to implement a way for MIRA to ask for additional metadata information from the app",
        "isfixed": false,
        "context": ""
      }
    ]
  },
  "User Experience & Interface": {
    "Systemic Issues": [
      {
        "filename": "main.py",
        "annotation": "# Use stderr for logs to prevent mixing with conversation output #ANNOTATION In addition to stderr.log we should build functionality that allows us to see logging happening in realtime. I struggle to see what is happening on the server when testing the app.",
        "isfixed": false,
        "context": "Developer wants a way to see logs in real-time, particularly when running on the server."
      },
      {
        "filename": "tools/workflows/workflow_manager.py",
        "annotation": "self.match_threshold = 0.65  # Default, can be overridden from config #ANNOTATION <- This should be a config only value",
        "isfixed": false,
        "context": "Developer suggests moving the match_threshold to config instead of having a hardcoded default."
      }
    ],
    "Major Refactors": [
      {
        "filename": "generalANNOATIONS.txt",
        "annotation": "#ANNOTATION Workflows should have the option to skip steps if MIRA deems the step already completed and has enough information to proceed to the following step.",
        "isfixed": false,
        "context": ""
      }
    ]
  }
}