I need to implement magic link authentication for my FastAPI application. I'm currently using hardcoded auth that needs to be replaced.

## Current Setup
- FastAPI backend
- SQLite database
- Redis available for caching/sessions
- Frontend: [specify your frontend framework]
- Email service: [specify - SendGrid/AWS SES/etc]

## Requirements
1. Remove all hardcoded authentication
2. Implement passwordless magic link authentication
3. Email-based login only - no passwords stored anywhere
4. 10-minute expiration for magic links
5. httpOnly cookies for sessions
6. Rate limiting: max 3 login attempts per email per hour

## Database Schema (SQLite)
Create these tables:
- users: id (UUID primary key), email (unique), created_at, last_login
- magic_links: id, email, token_hash, expires_at, used (boolean), created_at
- sessions: id, user_id, token_hash, device_fingerprint, expires_at, created_at

## Implementation Needed
1. User model with SQLAlchemy
2. POST /auth/request-login endpoint (sends magic link email)
3. GET /auth/verify/{token} endpoint (verifies link, creates session)
4. POST /auth/logout endpoint
5. get_current_user dependency for protected routes
6. Email service abstraction for sending links
7. Rate limiting middleware
8. Update all existing endpoints to use get_current_user dependency

## Security Requirements
- Hash tokens before storing
- Use secrets.urlsafe_base64() for token generation
- Validate email format
- Clean user-friendly error messages
- Log all auth attempts
- Set secure cookie flags (httpOnly, secure, sameSite)

## Example Flow
1. User enters email
2. System sends magic link
3. User clicks link
4. System creates session cookie
5. User accesses protected resources

Please implement this complete magic link authentication system, removing all hardcoded auth.





#####################################




I have a working magic link authentication system. Now I need to implement complete user data isolation so each user only sees their own data.

## Current State
- Magic link auth is working
- Users can login and get sessions
- get_current_user dependency exists
- Need to isolate all user data

## Requirements
1. Add user_id column to ALL data tables
2. Automatically filter all queries by current user
3. Prevent any cross-user data access
4. Add audit logging for data access
5. Make it impossible to accidentally query other users' data

## Database Changes Needed
1. Add user_id (UUID, foreign key) to every data table
2. Create indexes on user_id columns
3. Add audit_logs table: id, user_id, action, table_name, record_id, timestamp, ip_address

## Implementation Needed
1. Migration to add user_id to all existing tables
2. Custom SQLAlchemy session that auto-filters by user_id
3. Update all database queries to use current user
4. Middleware to inject user_id into all queries
5. Audit logging decorator for data access
6. Tests to verify data isolation

## Safety Mechanisms
1. Override SQLAlchemy query() to always filter by user_id
2. Prevent raw SQL execution
3. Add checks in all endpoints to verify user owns the resource
4. Create a UserScopedSession class that enforces filtering

## Example Implementation
```python
class UserScopedSession:
    def __init__(self, session, user_id):
        self.session = session
        self.user_id = user_id
    
    def query(self, model):
        # Automatically add user_id filter
        return self.session.query(model).filter(model.user_id == self.user_id)



Please implement complete user data isolation with the safety mechanisms described above.


####################################


## Prompt 3: Device Remember & Biometric Authentication
I have magic link auth with user data isolation working. Now I need to add biometric authentication options and "remember this device" functionality.
Current State

Magic links working
User data properly isolated
Basic sessions implemented

Requirements

WebAuthn/Passkey support for biometric login (TouchID/FaceID)
Biometric login can bypass magic links for registered devices
"Remember this device" option during login (30 days)
Device fingerprinting for security
List of active sessions for user
Ability to revoke sessions

Database Changes

Add webauthn_credentials table:

id, user_id, credential_id, public_key, device_name, last_used, created_at


Update sessions table:

device_name (e.g., "Chrome on MacOS")
device_hash (fingerprint)
is_remembered (boolean)
auth_method (magic_link, webauthn)
last_activity
ip_address
user_agent



Implementation Needed
Biometric Authentication

POST /auth/webauthn/register/begin - Start biometric registration
POST /auth/webauthn/register/complete - Complete registration
POST /auth/webauthn/login/begin - Start biometric login
POST /auth/webauthn/login/complete - Complete login
Use python-fido2 library for WebAuthn

Session Management

Update login flow to include "remember me" checkbox
GET /auth/sessions endpoint (list active sessions)
DELETE /auth/sessions/{session_id} endpoint (revoke session)
GET /auth/devices endpoint (list registered biometric devices)
DELETE /auth/devices/{device_id} endpoint (remove device)

Login Flow

Check if user has biometric registered
If yes, prompt for biometric first
Fall back to magic link if biometric fails
Always allow magic link as backup option

Security Features

Different expiry for biometric+remembered (30 days) vs magic link (24 hours)
Re-authenticate for sensitive actions
Alert user when new device registers
Maximum 5 biometric devices per user

Please implement biometric authentication with WebAuthn and device management features.



##################################

## Prompt 4: End-to-End Encryption Setup
I have a complete auth system with magic links and biometrics. Now I need to add optional end-to-end encryption for sensitive user data.
Current State

Magic link auth working
Biometric authentication implemented
User data isolation complete
Frontend: [framework] with Web Crypto API support

Requirements

Optional E2E encryption (users can opt-in)
Client-side encryption for sensitive fields
Server never sees encryption keys
Hybrid mode: some data E2E, some server-encrypted
Key derivation from email + user PIN/passphrase
Biometric unlock for E2E keys on supported devices

Database Changes
Create user_encryption_keys table:

user_id (foreign key)
encrypted_private_key (encrypted with user's passphrase)
public_key
key_salt
encryption_enabled (boolean)
biometric_key_available (boolean)
created_at

Modify user data tables:

Add encrypted_data column (for E2E data)
Keep existing columns for non-sensitive data

Backend Implementation

POST /encryption/setup endpoint (store encrypted keys)
GET /encryption/status endpoint
POST /encryption/biometric/enable endpoint (enable biometric unlock)
Update data endpoints to handle encrypted/unencrypted data
Add encryption_enabled flag to user session

Frontend Implementation Needed

E2E setup flow after first login:

Explain benefits
Create PIN/passphrase
Generate keypair
Encrypt private key with passphrase
Offer biometric key storage on supported devices
Send to server


Encryption service:

javascriptclass EncryptionService {
    async generateKeys() { }
    async deriveKey(email, passphrase) { }
    async encryptData(data, publicKey) { }
    async decryptData(encryptedData, privateKey) { }
    async storeBiometricKey(privateKey) { } // Using device secure storage
    async getBiometricKey() { } // Unlock with TouchID/FaceID
}

Auto-encrypt/decrypt sensitive fields
Use biometric to unlock E2E keys when available
Fall back to PIN/passphrase when biometric unavailable

Security Requirements

Use Web Crypto API only
Never send passphrase to server
Store E2E keys in device secure enclave when using biometric
Clear memory after crypto operations
Support key rotation

Please implement the E2E encryption system with biometric unlock support.



#########################################

## Prompt 5: Key Recovery & Final Security Hardening
I have magic links, biometrics, data isolation, and E2E encryption working. Now I need to add key recovery mechanisms and final security hardening.
Current State

Full auth system with magic links and biometrics
E2E encryption optional for users
Data properly isolated

Requirements

Key recovery mechanism for E2E users
Security headers and CORS
Comprehensive audit logging
Rate limiting on all endpoints
Security monitoring alerts

Key Recovery Implementation

Security questions (3 required, 2 to recover):

Store hashed answers
Custom questions preferred
48-hour delay on recovery


Recovery codes:

Generate 8 codes on E2E setup
Single use only
User must save them


Biometric device as recovery method:

Allow using registered biometric device to recover
Require magic link + biometric for recovery


Recovery endpoints:

POST /recovery/initiate
POST /recovery/verify
POST /recovery/biometric (if user has registered device)
GET /recovery/status



Security Hardening

Add security headers middleware:

Content-Security-Policy
X-Frame-Options
X-Content-Type-Options
Strict-Transport-Security


Comprehensive audit logging:

All auth attempts (magic link and biometric)
All data access
All encryption/decryption events
Failed authentication attempts
Device registrations


Rate limiting per endpoint:

/auth/*: 3 per hour
/auth/webauthn/*: 10 per hour (biometric attempts)
/api/*: 100 per hour
/recovery/*: 1 per day


Monitoring alerts for:

Multiple failed login attempts
Login from new location
New biometric device registered
Recovery attempt initiated
Unusual data access patterns



Implementation Needed

Recovery flow with time delay
Biometric-assisted recovery option
Security headers middleware
Enhanced audit logging with device tracking
Rate limiting with Redis
Alert system (email admin on suspicious activity)
GET /security/audit endpoint for users to see their activity
GET /security/devices endpoint to manage all auth methods

Please implement the key recovery system and security hardening features to complete the secure authentication system.