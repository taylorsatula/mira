# Working Memory Implementation Plan - Updated

## Overview

This document outlines the strategy for implementing a centralized `WorkingMemory` system to manage dynamic content in system prompts. Currently, dynamic information is added to system prompts through various standalone mechanisms without a unified approach. The new design standardizes this process, improving maintainability and extensibility.

## Current Architecture

Currently, dynamic system prompt content is managed in several disparate ways:

- **Date and time information**: Added directly in `conversation.py`
- **Tool guidance**: Generated in `ToolRepository` but added in `conversation.py`
- **Workflow state**: Generated by `WorkflowManager.get_system_prompt_extension()` and added in `conversation.py`
- **User information**: Loaded from files by `AppConfig` and treated as static content

This leads to several problems:
1. The `Conversation` class has too many responsibilities
2. Components cannot update their content independently
3. No standardized interface for managing dynamic content
4. Difficult to track what is in the system prompt at any given time

## New Architecture: WorkingMemory

The new architecture introduces a centralized `WorkingMemory` class with "trinkets" - utility classes that manage specific types of memory content. This design:

1. Provides a standard interface for adding/removing content
2. Categorizes content for better organization
3. Allows components to manage their own prompt content
4. Centralizes the assembly of dynamic system prompt content

```
                  → WorkingMemory ←
                ↗       |         ↖  
MemoryTrinkets-↗        |          ↖-ToolGuidance
                        ↓ 
                  Conversation      
```

## Implemented Components

### WorkingMemory Class

The `WorkingMemory` class serves as the central store for dynamic prompt content. It provides methods to:

- Add content with a specific category
- Remove content by ID or category
- Retrieve formatted content for system prompts
- Query content by category

### Memory Trinkets

We've implemented several "trinkets" to manage specific types of content:

1. **TimeManager**
   - Updates current date and time information 
   - Formats in both local and UTC time

2. **UserInfoManager**
   - Loads user information from files
   - Provides reload functionality

3. **WorkflowHintManager**
   - Manages workflow detection hints
   - Updates active workflow guidance

4. **ToolGuidanceManager**
   - Provides guidance when multiple tools are enabled
   - Shows available tools to the assistant

5. **SystemStatusManager**
   - Tracks system status information
   - Manages notification messages

## Integration Points

### Main.py

The `main.py` file initializes the WorkingMemory and trinkets, then passes them to the Conversation:

```python
# Create working memory instance
working_memory = WorkingMemory()

# Initialize trinkets
time_manager = TimeManager(working_memory)
user_info_manager = UserInfoManager(working_memory, config)
workflow_hint_manager = WorkflowHintManager(working_memory, workflow_manager)
tool_guidance_manager = ToolGuidanceManager(working_memory, tool_repo)

# Initialize conversation with working memory
conversation = Conversation(
    conversation_id=conversation_id,
    system_prompt=system_prompt,
    llm_bridge=llm_bridge,
    tool_repo=tool_repo,
    tool_relevance_engine=tool_relevance_engine,
    workflow_manager=workflow_manager,
    working_memory=working_memory
)
```

### Updating Memory Content

Before generating each response, main.py updates the dynamic content:

```python
# Update dynamic information in working memory before each response
system['time_manager'].update_datetime_info()
system['workflow_hint_manager'].update_workflow_guidance()
system['tool_guidance_manager'].update_tool_guidance()
```

### Conversation Integration

The Conversation class now uses WorkingMemory to get dynamic content:

```python
# Get dynamic content from working memory
dynamic_content = self.working_memory.get_prompt_content()
```

## Testing

We've created comprehensive tests for all components:

1. **WorkingMemory Tests**
   - Basic add/remove operations
   - Content formatting
   - Category-based operations

2. **Trinket Tests**
   - TimeManager
   - UserInfoManager
   - WorkflowHintManager
   - ToolGuidanceManager
   - SystemStatusManager

## Benefits of the New Architecture

The WorkingMemory architecture offers several benefits:

1. **Separation of Concerns**:
   - Each component manages its own content
   - Conversation only needs to get content from WorkingMemory

2. **Centralized Management**:
   - All dynamic content flows through one system
   - Clear view of what's in the system prompt

3. **Extensibility**:
   - New content types can be added via new trinkets
   - Existing components don't need to change

4. **Maintainability**:
   - Simpler code in Conversation class
   - Better organization of related functionality

5. **Testing**:
   - Each component can be tested in isolation
   - Easier to mock dependencies

## Next Steps

1. **Full Integration with Workflows**:
   - Update WorkflowManager to use WorkingMemory directly
   - Remove the workflow-specific integration in Conversation

2. **Refine Tool Guidance**:
   - Enhance tool guidance with more specific help
   - Add examples of tool usage

3. **Performance Optimization**:
   - Monitor memory usage and performance
   - Consider caching strategies for large content items

4. **Documentation Updates**:
   - Add developer guidelines for using WorkingMemory
   - Document the trinket pattern for future extensions

## Conclusion

The WorkingMemory system represents a significant architectural improvement that standardizes how dynamic content is managed in system prompts. By providing a centralized interface and clear responsibilities, this change improves maintainability, extensibility, and code organization.

The implementation follows a clean design pattern that separates concerns and makes the system more modular. The use of "trinkets" provides a flexible way to extend the system with new content types without affecting existing components.