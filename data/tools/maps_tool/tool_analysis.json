{
  "tool_name": "maps_tool",
  "tool_code": "\"\"\"\nMaps API integration tool.\n\nThis tool enables the bot to interact with Maps APIs to resolve\nnatural language location queries to coordinates, retrieve place details,\nand perform geocoding operations.\n\nRequires Maps API key in the config file.\n\"\"\"\n\nimport logging\nimport os\nimport json\nfrom typing import Dict, List, Any, Optional, Union\n\nfrom tools.repo import Tool\nfrom errors import ToolError, ErrorCode, error_context\nfrom config import config\n\n\nclass MapsTool(Tool):\n    \"\"\"\n    Tool for interacting with Maps APIs to resolve locations and places.\n\n    Features:\n    1. Geocoding:\n       - Convert natural language queries to lat/long coordinates\n       - Resolve place names to specific locations\n       - Support for structured and unstructured address inputs\n\n    2. Place Details:\n       - Get detailed information about places\n       - Retrieve business information, opening hours, ratings\n       - Get contact information for businesses\n\n    3. Reverse Geocoding:\n       - Convert coordinates to formatted addresses\n       - Get neighborhood, city, state information from coordinates\n    \"\"\"\n\n    name = \"maps_tool\"\n    description = \"\"\"Provides comprehensive location intelligence and geographical services through Maps API integration.\n\nThis tool enables interaction with mapping services for various location-based operations including:\n\n1. geocode: Convert natural language locations to precise coordinates.\n   - Requires 'query' parameter with address, landmark, or place name\n   - Returns formatted address, geographic coordinates, and place information\n\n2. reverse_geocode: Convert coordinates to address information.\n   - Requires 'lat' and 'lng' parameters as decimal degrees\n   - Returns detailed address components for the specified location\n\n3. place_details: Retrieve comprehensive information about specific places.\n   - Requires 'place_id' parameter (unique place identifier)\n   - Returns name, address, phone number, website, opening hours, and other details\n\n4. places_nearby: Discover places around a specific location.\n   - Requires 'lat' and 'lng' parameters for center point\n   - Optional parameters: 'radius' (default 1000m), 'type' (e.g., restaurant), 'keyword', 'open_now'\n   - Returns matching places sorted by proximity with ratings and details\n\n5. find_place: Locate specific places by name or description.\n   - Requires 'query' parameter with place name\n   - Returns precise match results with location data\n\n6. calculate_distance: Determine distance between two geographic points.\n   - Requires 'lat1', 'lng1', 'lat2', 'lng2' parameters\n   - Returns distance in meters, kilometers, and miles\n\nUse this tool for any task requiring location resolution, place discovery, geocoding, or geographic calculations.\"\"\"\n    usage_examples = [\n        # # Example 1: Geocode an address\n        # {\n        #     \"input\": {\n        #         \"operation\": \"geocode\",\n        #         \"query\": \"Eiffel Tower, Paris\"\n        #     },\n        #     \"output\": {\n        #         \"results\": [\n        #             {\n        #                 \"formatted_address\": \"Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France\",\n        #                 \"place_id\": \"ChIJLU7jZClu5kcR4PcOOO6p3I0\",\n        #                 \"location\": {\n        #                     \"lat\": 48.8583701,\n        #                     \"lng\": 2.2944813\n        #                 },\n        #                 \"types\": [\"tourist_attraction\", \"point_of_interest\", \"establishment\"]\n        #             }\n        #         ]\n        #     }\n        # },\n        # # Example 2: Get place details\n        # {\n        #     \"input\": {\n        #         \"operation\": \"place_details\",\n        #         \"place_id\": \"ChIJLU7jZClu5kcR4PcOOO6p3I0\"\n        #     },\n        #     \"output\": {\n        #         \"name\": \"Eiffel Tower\",\n        #         \"formatted_address\": \"Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France\",\n        #         \"formatted_phone_number\": \"+33 892 70 12 39\",\n        #         \"location\": {\n        #             \"lat\": 48.8583701,\n        #             \"lng\": 2.2944813\n        #         },\n        #         \"opening_hours\": {\n        #             \"open_now\": True,\n        #             \"periods\": [\n        #                 {\n        #                     \"open\": {\"day\": 0, \"time\": \"0930\"},\n        #                     \"close\": {\"day\": 0, \"time\": \"2245\"}\n        #                 }\n        #             ]\n        #         },\n        #         \"rating\": 4.6,\n        #         \"website\": \"https://www.toureiffel.paris/en\"\n        #     }\n        # },\n        # # Example 3: Reverse geocode coordinates\n        # {\n        #     \"input\": {\n        #         \"operation\": \"reverse_geocode\",\n        #         \"lat\": 48.8583701,\n        #         \"lng\": 2.2944813\n        #     },\n        #     \"output\": {\n        #         \"results\": [\n        #             {\n        #                 \"formatted_address\": \"Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France\",\n        #                 \"place_id\": \"ChIJLU7jZClu5kcR4PcOOO6p3I0\",\n        #                 \"types\": [\"tourist_attraction\", \"point_of_interest\", \"establishment\"]\n        #             }\n        #         ]\n        #     }\n        # },\n        # # Example 4: Places nearby search\n        # {\n        #     \"input\": {\n        #         \"operation\": \"places_nearby\",\n        #         \"lat\": 48.8583701, \n        #         \"lng\": 2.2944813,\n        #         \"radius\": 1000,\n        #         \"type\": \"restaurant\"\n        #     },\n        #     \"output\": {\n        #         \"results\": [\n        #             {\n        #                 \"name\": \"Le Jules Verne\",\n        #                 \"place_id\": \"ChIJe8hLsClw5kcRCA4gYfL5Pxc\",\n        #                 \"vicinity\": \"Avenue Gustave Eiffel, Paris\",\n        #                 \"types\": [\"restaurant\", \"point_of_interest\", \"establishment\"],\n        #                 \"rating\": 4.1\n        #             }\n        #         ]\n        #     }\n        # },\n        # # Example 5: Find place operation\n        # {\n        #     \"input\": {\n        #         \"operation\": \"find_place\",\n        #         \"query\": \"Huntsville Hospital\"\n        #     },\n        #     \"output\": {\n        #         \"results\": [\n        #             {\n        #                 \"name\": \"Huntsville Hospital\",\n        #                 \"place_id\": \"ChIJJZZlLNdrYogR44PRuZ4EXU8\",\n        #                 \"formatted_address\": \"101 Sivley Rd SW, Huntsville, AL 35801, USA\",\n        #                 \"location\": {\n        #                     \"lat\": 34.7211561,\n        #                     \"lng\": -86.5807587\n        #                 }\n        #             }\n        #         ]\n        #     }\n        # },\n        # # Example 6: Calculate distance between two points\n        # {\n        #     \"input\": {\n        #         \"operation\": \"calculate_distance\",\n        #         \"lat1\": 34.7211561,\n        #         \"lon1\": -86.5807587,\n        #         \"lat2\": 34.7304944,\n        #         \"lon2\": -86.5860382\n        #     },\n        #     \"output\": {\n        #         \"distance_meters\": 1057.84,\n        #         \"distance_kilometers\": 1.05784,\n        #         \"distance_miles\": 0.6573\n        #     }\n        # }\n    ]\n\n    def __init__(self):\n        \"\"\"Initialize the Google Maps tool.\"\"\"\n        super().__init__()\n        self.logger = logging.getLogger(__name__)\n        self._client = None\n\n    @property\n    def client(self):\n        \"\"\"\n        Get the Google Maps client, initializing it if needed.\n        Lazy loading approach.\n\n        Returns:\n            Google Maps client instance\n\n        Raises:\n            ToolError: If Google Maps API key is not set or client initialization fails\n        \"\"\"\n        if self._client is None:\n            try:\n                from googlemaps import Client\n\n                # Get API key from config\n                api_key = config.google_maps_api_key\n                if not api_key:\n                    raise ToolError(\n                        \"Google Maps API key not found in configuration.\",\n                        ErrorCode.TOOL_EXECUTION_ERROR,\n                    )\n\n                # Create client with API key\n                self.logger.info(\"Creating Google Maps client with API key\")\n                self._client = Client(key=api_key)\n            except ImportError:\n                raise ToolError(\n                    \"googlemaps library not installed. Run: pip install googlemaps\",\n                    ErrorCode.TOOL_INITIALIZATION_ERROR,\n                )\n            except Exception as e:\n                self.logger.error(f\"Failed to initialize Google Maps client: {e}\")\n                raise ToolError(\n                    f\"Failed to initialize Google Maps client: {e}\",\n                    ErrorCode.TOOL_EXECUTION_ERROR,\n                )\n        return self._client\n\n        \n    def _geocode(self, query: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Convert a natural language query to geographic coordinates.\n\n        Args:\n            query: Address, landmark name, or place description\n\n        Returns:\n            List of matching locations with coordinates and other details\n        \"\"\"\n        try:\n            # Get geocoding parameters\n            params = {\"address\": query}\n            \n            # Call geocoding API\n            results = self.client.geocode(**params)\n            processed_results = []\n\n            for result in results:\n                # Extract and format the important information\n                processed_result = {\n                    \"formatted_address\": result.get(\"formatted_address\", \"\"),\n                    \"place_id\": result.get(\"place_id\", \"\"),\n                    \"location\": result.get(\"geometry\", {}).get(\"location\", {}),\n                    \"types\": result.get(\"types\", [])\n                }\n                processed_results.append(processed_result)\n\n            return processed_results\n        except Exception as e:\n            self.logger.error(f\"Geocoding error: {e}\")\n            raise ToolError(f\"Failed to geocode query: {e}\", ErrorCode.TOOL_EXECUTION_ERROR)\n\n    def _reverse_geocode(self, lat: float, lng: float) -> List[Dict[str, Any]]:\n        \"\"\"\n        Convert geographic coordinates to an address.\n\n        Args:\n            lat: Latitude\n            lng: Longitude\n\n        Returns:\n            List of address information for the coordinates\n        \"\"\"\n        try:\n            results = self.client.reverse_geocode((lat, lng))\n            processed_results = []\n\n            for result in results:\n                # Extract and format the important information\n                processed_result = {\n                    \"formatted_address\": result.get(\"formatted_address\", \"\"),\n                    \"place_id\": result.get(\"place_id\", \"\"),\n                    \"types\": result.get(\"types\", [])\n                }\n                processed_results.append(processed_result)\n\n            return processed_results\n        except Exception as e:\n            self.logger.error(f\"Reverse geocoding error: {e}\")\n            raise ToolError(\n                f\"Failed to reverse geocode coordinates: {e}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n\n    def _place_details(self, place_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a place.\n\n        Args:\n            place_id: Google Places ID\n\n        Returns:\n            Dict containing place details\n        \"\"\"\n        try:\n            result = self.client.place(place_id=place_id)\n            \n            # Extract place details from the result\n            if \"result\" in result:\n                place = result[\"result\"]\n                \n                # Extract the necessary details\n                details = {\n                    \"name\": place.get(\"name\", \"\"),\n                    \"formatted_address\": place.get(\"formatted_address\", \"\"),\n                    \"formatted_phone_number\": place.get(\"formatted_phone_number\", \"\"),\n                    \"international_phone_number\": place.get(\"international_phone_number\", \"\"),\n                    \"website\": place.get(\"website\", \"\"),\n                    \"url\": place.get(\"url\", \"\"),\n                    \"rating\": place.get(\"rating\", 0),\n                    \"types\": place.get(\"types\", []),\n                }\n                \n                # Add location if available\n                if \"geometry\" in place and \"location\" in place[\"geometry\"]:\n                    details[\"location\"] = place[\"geometry\"][\"location\"]\n                \n                # Add opening hours if available\n                if \"opening_hours\" in place:\n                    details[\"opening_hours\"] = place[\"opening_hours\"]\n                \n                return details\n            else:\n                raise ToolError(\n                    f\"No details found for place ID: {place_id}\",\n                    ErrorCode.TOOL_EXECUTION_ERROR\n                )\n                \n        except Exception as e:\n            self.logger.error(f\"Place details error: {e}\")\n            raise ToolError(\n                f\"Failed to get place details: {e}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n\n    def _places_nearby(\n        self, \n        lat: float, \n        lng: float, \n        radius: int = 1000,\n        keyword: Optional[str] = None,\n        type: Optional[str] = None,\n        language: Optional[str] = None,\n        open_now: Optional[bool] = None\n    ) -> List[Dict[str, Any]]:\n        \"\"\"\n        Find places near a specific location.\n\n        Args:\n            lat: Latitude of the center point\n            lng: Longitude of the center point\n            radius: Search radius in meters (default 1000)\n            keyword: Keywords describing the place\n            type: Type of place (e.g., restaurant, cafe)\n            language: Language for results\n            open_now: Whether to return only places open at the time of request\n\n        Returns:\n            List of places near the specified location\n        \"\"\"\n        try:\n            # Prepare search parameters\n            params = {\n                \"location\": (lat, lng),\n                \"radius\": radius\n            }\n            \n            # Add optional parameters if provided\n            if keyword:\n                params[\"keyword\"] = keyword\n            if type:\n                params[\"type\"] = type\n            if language:\n                params[\"language\"] = language\n            if open_now is not None:\n                params[\"open_now\"] = open_now\n                \n            # Perform the search\n            results = self.client.places_nearby(**params)\n            \n            # Process and return the results\n            if \"results\" in results:\n                processed_results = []\n                \n                for place in results[\"results\"]:\n                    processed_place = {\n                        \"name\": place.get(\"name\", \"\"),\n                        \"place_id\": place.get(\"place_id\", \"\"),\n                        \"vicinity\": place.get(\"vicinity\", \"\"),\n                        \"types\": place.get(\"types\", []),\n                    }\n                    \n                    # Add location if available\n                    if \"geometry\" in place and \"location\" in place[\"geometry\"]:\n                        processed_place[\"location\"] = place[\"geometry\"][\"location\"]\n                    \n                    # Add rating if available\n                    if \"rating\" in place:\n                        processed_place[\"rating\"] = place[\"rating\"]\n                    \n                    # Add open_now if available\n                    if \"opening_hours\" in place and \"open_now\" in place[\"opening_hours\"]:\n                        processed_place[\"open_now\"] = place[\"opening_hours\"][\"open_now\"]\n                        \n                    processed_results.append(processed_place)\n                    \n                return processed_results\n            else:\n                return []\n                \n        except Exception as e:\n            self.logger.error(f\"Places nearby search error: {e}\")\n            raise ToolError(\n                f\"Failed to search nearby places: {e}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n\n    def _find_place(self, query: str, fields: Optional[List[str]] = None) -> Dict[str, Any]:\n        \"\"\"\n        Find a specific place using a text query (more precise than places_text_search).\n        \n        Args:\n            query: The text identifying the place (name, address, etc.)\n            fields: Optional fields to include in the result\n            \n        Returns:\n            Dictionary containing place information\n        \"\"\"\n        try:\n            # Default fields if not specified\n            if fields is None:\n                fields = [\n                    'place_id', 'name', 'formatted_address', 'geometry', \n                    'types', 'business_status', 'rating'\n                ]\n            \n            # Prepare parameters\n            params = {\n                \"input\": query,\n                \"input_type\": \"textquery\",\n                \"fields\": fields\n            }\n            \n            # Call Find Place API\n            results = self.client.find_place(**params)\n            \n            # Process and return results\n            if \"candidates\" in results and results[\"candidates\"]:\n                processed_results = []\n                \n                for place in results[\"candidates\"]:\n                    processed_place = {\n                        \"name\": place.get(\"name\", \"\"),\n                        \"place_id\": place.get(\"place_id\", \"\"),\n                        \"formatted_address\": place.get(\"formatted_address\", \"\"),\n                        \"types\": place.get(\"types\", []),\n                    }\n                    \n                    # Add location if available\n                    if \"geometry\" in place and \"location\" in place[\"geometry\"]:\n                        processed_place[\"location\"] = place[\"geometry\"][\"location\"]\n                    \n                    # Add rating if available\n                    if \"rating\" in place:\n                        processed_place[\"rating\"] = place[\"rating\"]\n                        \n                    processed_results.append(processed_place)\n                    \n                return {\"results\": processed_results}\n            else:\n                return {\"results\": []}\n                \n        except Exception as e:\n            self.logger.error(f\"Find place error: {e}\")\n            raise ToolError(\n                f\"Failed to find place: {e}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    def _places_text_search(self, query: str, location: Optional[tuple] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        Search for places using a text query.\n\n        Args:\n            query: Search query text\n            location: Optional (latitude, longitude) tuple to bias results\n\n        Returns:\n            List of places matching the search query\n        \"\"\"\n        try:\n            # Prepare search parameters\n            params = {\"query\": query}\n            \n            # Add location for result biasing if provided\n            if location:\n                params[\"location\"] = location\n                    \n            # Perform the search\n            results = self.client.places(**params)\n            \n            # Process and return the results\n            if \"results\" in results:\n                processed_results = []\n                \n                for place in results[\"results\"]:\n                    processed_place = {\n                        \"name\": place.get(\"name\", \"\"),\n                        \"place_id\": place.get(\"place_id\", \"\"),\n                        \"formatted_address\": place.get(\"formatted_address\", \"\"),\n                        \"types\": place.get(\"types\", []),\n                    }\n                    \n                    # Add location if available\n                    if \"geometry\" in place and \"location\" in place[\"geometry\"]:\n                        processed_place[\"location\"] = place[\"geometry\"][\"location\"]\n                    \n                    # Add rating if available\n                    if \"rating\" in place:\n                        processed_place[\"rating\"] = place[\"rating\"]\n                        \n                    processed_results.append(processed_place)\n                    \n                return processed_results\n            else:\n                return []\n                \n        except Exception as e:\n            self.logger.error(f\"Places text search error: {e}\")\n            raise ToolError(\n                f\"Failed to perform text search: {e}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n\n    def _haversine_distance(self, lat1: float, lng1: float, lat2: float, lng2: float) -> float:\n        \"\"\"\n        Calculate the great circle distance between two points on the Earth.\n        Uses the haversine formula.\n        \n        Args:\n            lat1: Latitude of point 1 (in degrees)\n            lng1: Longitude of point 1 (in degrees)\n            lat2: Latitude of point 2 (in degrees)\n            lng2: Longitude of point 2 (in degrees)\n            \n        Returns:\n            Distance in meters between the points\n        \"\"\"\n        import math\n        \n        # Convert decimal degrees to radians\n        lat1, lng1, lat2, lng2 = map(math.radians, [lat1, lng1, lat2, lng2])\n        \n        # Haversine formula\n        dlat = lat2 - lat1\n        dlng = lng2 - lng1\n        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlng/2)**2\n        c = 2 * math.asin(math.sqrt(a))\n        # Radius of Earth in meters\n        r = 6371000\n        return c * r\n        \n    def run(\n        self,\n        operation: str,\n        query: Optional[str] = None,\n        place_id: Optional[str] = None,\n        lat: Optional[float] = None,\n        lng: Optional[float] = None,\n        lat1: Optional[float] = None,\n        lng1: Optional[float] = None,\n        lat2: Optional[float] = None,\n        lng2: Optional[float] = None,\n        radius: Optional[int] = None,\n        type: Optional[str] = None,\n        keyword: Optional[str] = None,\n        open_now: Optional[bool] = None,\n        language: Optional[str] = None,\n        fields: Optional[List[str]] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute a Google Maps API operation.\n\n        Args:\n            operation: Operation to perform (see below for valid operations)\n            query: Search query for geocoding or places text search\n            place_id: Google Places ID for place details\n            lat: Latitude for operations requiring coordinates\n            lng: Longitude for operations requiring coordinates\n            lat1: First latitude for distance calculations\n            lng1: First longitude for distance calculations \n            lat2: Second latitude for distance calculations\n            lng2: Second longitude for distance calculations\n            radius: Search radius in meters for nearby places\n            type: Type of place (e.g., restaurant, cafe)\n            keyword: Search keywords\n            open_now: Filter results to those open at request time\n            language: Language for results\n            fields: Specific fields to request from the API (for find_place)\n\n        Returns:\n            Response data for the operation\n\n        Raises:\n            ToolError: If operation fails or parameters are invalid\n\n        Valid Operations:\n\n        1. geocode: Convert natural language query to coordinates\n           - Required: query (address, landmark name, or place description)\n           - Returns: List of matching locations with coordinates\n\n        2. reverse_geocode: Convert coordinates to address\n           - Required: lat, lng\n           - Returns: List of address information for the coordinates\n\n        3. place_details: Get detailed information about a place\n           - Required: place_id\n           - Returns: Dict with place details including address, phone, hours, etc.\n\n        4. places_nearby: Find places near a specific location\n           - Required: lat, lng\n           - Optional: radius (default 1000m), type, keyword, open_now, language\n           - Returns: List of places near the specified location\n\n        5. places_text_search: Search for places using a text query\n           - Required: query\n           - Optional: lat, lng (for result biasing)\n           - Returns: List of places matching the search query\n           \n        6. find_place: Find a specific place using a text query (most precise option)\n           - Required: query (name of place, business, landmark, etc.)\n           - Optional: fields (list of specific fields to request)\n           - Returns: List of matching places with detailed information\n           \n        7. calculate_distance: Calculate the distance between two geographic points\n           - Required: lat1, lng1, lat2, lng2 (coordinates in decimal degrees)\n           - Returns: Distance in meters between the points\n        \"\"\"\n        with error_context(\n            component_name=self.name,\n            operation=f\"executing {operation}\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger,\n        ):\n            # Check for missing coordinates in places operations where they're required\n            coordinate_required_operations = ['places_nearby', 'reverse_geocode']\n            if operation in coordinate_required_operations and (lat is None or lng is None):\n                return {\n                    \"error\": \"This operation requires location data. Please allow location access in your app.\",\n                    \"requires_location\": True\n                }\n            \n            # Handle JSON string passed in 'params' field\n            if \"params\" in operation and isinstance(operation, dict) and isinstance(operation[\"params\"], str):\n                try:\n                    params = json.loads(operation[\"params\"])\n                    operation = params.get(\"operation\", operation)\n                    query = params.get(\"query\", query)\n                    place_id = params.get(\"place_id\", place_id)\n                    lat = params.get(\"lat\", lat)\n                    lng = params.get(\"lng\", lng)\n                    radius = params.get(\"radius\", radius)\n                    type = params.get(\"type\", type)\n                    keyword = params.get(\"keyword\", keyword)\n                    open_now = params.get(\"open_now\", open_now)\n                    language = params.get(\"language\", language)\n                except json.JSONDecodeError as e:\n                    raise ToolError(\n                        f\"Invalid JSON in params: {e}\", ErrorCode.TOOL_INVALID_INPUT\n                    )\n\n            # Geocoding Operations\n            if operation == \"geocode\":\n                if not query:\n                    raise ToolError(\n                        \"query parameter is required for geocode operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                results = self._geocode(query)\n                return {\"results\": results}\n\n            elif operation == \"reverse_geocode\":\n                if lat is None or lng is None:\n                    raise ToolError(\n                        \"lat and lng parameters are required for reverse_geocode operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                results = self._reverse_geocode(lat, lng)\n                return {\"results\": results}\n\n            # Place Operations\n            elif operation == \"place_details\":\n                if not place_id:\n                    raise ToolError(\n                        \"place_id parameter is required for place_details operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                return self._place_details(place_id)\n\n            elif operation == \"places_nearby\":\n                if lat is None or lng is None:\n                    raise ToolError(\n                        \"lat and lng parameters are required for places_nearby operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                results = self._places_nearby(\n                    lat=lat,\n                    lng=lng,\n                    radius=radius or 1000,\n                    keyword=keyword,\n                    type=type,\n                    language=language,\n                    open_now=open_now\n                )\n                return {\"results\": results}\n\n            elif operation == \"places_text_search\":\n                if not query:\n                    raise ToolError(\n                        \"query parameter is required for places_text_search operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                location = (lat, lng) if lat is not None and lng is not None else None\n                results = self._places_text_search(\n                    query=query, \n                    location=location\n                )\n                return {\"results\": results}\n\n            elif operation == \"find_place\":\n                if not query:\n                    raise ToolError(\n                        \"query parameter is required for find_place operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                return self._find_place(\n                    query=query, \n                    fields=fields\n                )\n\n            elif operation == \"calculate_distance\":\n                if lat1 is None or lng1 is None or lat2 is None or lng2 is None:\n                    raise ToolError(\n                        \"lat1, lng1, lat2, lng2 parameters are required for calculate_distance operation\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                \n                try:\n                    # Convert to float if they aren't already\n                    lat1_val = float(lat1)\n                    lng1_val = float(lng1)\n                    lat2_val = float(lat2)\n                    lng2_val = float(lng2)\n                    \n                    # Calculate distance\n                    distance = self._haversine_distance(lat1_val, lng1_val, lat2_val, lng2_val)\n                    \n                    return {\n                        \"distance_meters\": distance,\n                        \"distance_kilometers\": distance / 1000,\n                        \"distance_miles\": distance / 1609.34\n                    }\n                except ValueError:\n                    raise ToolError(\n                        \"Coordinates must be valid numbers\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                    )\n                \n            else:\n                raise ToolError(\n                    f\"Unknown operation: {operation}. Valid operations are: \"\n                    \"geocode, reverse_geocode, place_details, places_nearby, places_text_search, find_place, calculate_distance\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                )",
  "description": "A tool for interacting with Maps APIs to resolve natural language location queries to coordinates, retrieve place details, and perform geocoding operations.",
  "operations": [
    {
      "name": "geocode",
      "description": "Converts natural language location queries to precise geographic coordinates and formatted addresses.",
      "required_parameters": [
        {
          "name": "query",
          "type": "string",
          "description": "Address, landmark name, or place description to geocode"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "reverse_geocode",
      "description": "Converts geographic coordinates to formatted addresses and place information.",
      "required_parameters": [
        {
          "name": "lat",
          "type": "float",
          "description": "Latitude coordinate in decimal degrees"
        },
        {
          "name": "lng",
          "type": "float",
          "description": "Longitude coordinate in decimal degrees"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "place_details",
      "description": "Retrieves comprehensive information about a specific place using its unique identifier.",
      "required_parameters": [
        {
          "name": "place_id",
          "type": "string",
          "description": "Google Places unique identifier for the location"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "places_nearby",
      "description": "Discovers places around a specific location based on various criteria.",
      "required_parameters": [
        {
          "name": "lat",
          "type": "float",
          "description": "Latitude of the center point"
        },
        {
          "name": "lng",
          "type": "float",
          "description": "Longitude of the center point"
        }
      ],
      "optional_parameters": [
        {
          "name": "radius",
          "type": "int",
          "description": "Search radius in meters",
          "default": 1000
        },
        {
          "name": "keyword",
          "type": "string",
          "description": "Keywords describing the place",
          "default": null
        },
        {
          "name": "type",
          "type": "string",
          "description": "Type of place (e.g., restaurant, cafe)",
          "default": null
        },
        {
          "name": "language",
          "type": "string",
          "description": "Language for results",
          "default": null
        },
        {
          "name": "open_now",
          "type": "boolean",
          "description": "Whether to return only places open at the time of request",
          "default": null
        }
      ]
    },
    {
      "name": "places_text_search",
      "description": "Searches for places using a text query with optional location biasing.",
      "required_parameters": [
        {
          "name": "query",
          "type": "string",
          "description": "Search query text"
        }
      ],
      "optional_parameters": [
        {
          "name": "lat",
          "type": "float",
          "description": "Latitude for result biasing",
          "default": null
        },
        {
          "name": "lng",
          "type": "float",
          "description": "Longitude for result biasing",
          "default": null
        }
      ]
    },
    {
      "name": "find_place",
      "description": "Locates specific places by name or description with high precision.",
      "required_parameters": [
        {
          "name": "query",
          "type": "string",
          "description": "Text identifying the place (name, address, etc.)"
        }
      ],
      "optional_parameters": [
        {
          "name": "fields",
          "type": "List[str]",
          "description": "Specific fields to request from the API",
          "default": [
            "place_id",
            "name",
            "formatted_address",
            "geometry",
            "types",
            "business_status",
            "rating"
          ]
        }
      ]
    },
    {
      "name": "calculate_distance",
      "description": "Calculates the distance between two geographic points using the haversine formula.",
      "required_parameters": [
        {
          "name": "lat1",
          "type": "float",
          "description": "Latitude of first point in decimal degrees"
        },
        {
          "name": "lng1",
          "type": "float",
          "description": "Longitude of first point in decimal degrees"
        },
        {
          "name": "lat2",
          "type": "float",
          "description": "Latitude of second point in decimal degrees"
        },
        {
          "name": "lng2",
          "type": "float",
          "description": "Longitude of second point in decimal degrees"
        }
      ],
      "optional_parameters": []
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}