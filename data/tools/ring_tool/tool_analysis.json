{
  "tool_name": "ring_tool",
  "tool_code": "\"\"\"\nRing Security System integration tool.\n\nThis tool enables integration with Ring security systems, allowing control of\nalarm systems, checking device status, and listing locations.\n\"\"\"\nimport json\nimport logging\nimport os\nimport time\nimport uuid\nimport platform\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional, Union, Tuple\nimport re\nimport requests\nfrom urllib.parse import urljoin\n\nfrom tools.repo import Tool\nfrom errors import ToolError, ErrorCode, error_context\nfrom config import config\n\n# Constants\nAUTH_URL = \"https://oauth.ring.com/oauth/token\"\nAPI_VERSION = 11\nCLIENT_API_BASE_URL = \"https://api.ring.com/clients_api/\"\nDEVICE_API_BASE_URL = \"https://api.ring.com/devices/v1/\"\nAPP_API_BASE_URL = \"https://app.ring.com/api/v1/\"\n\n\ndef generate_hardware_id() -> str:\n    \"\"\"\n    Generate a unique hardware ID for authentication.\n    \n    Returns:\n        A unique hardware ID string\n    \"\"\"\n    # Create a deterministic hardware ID based on machine info\n    system_info = platform.uname()\n    base = f\"{system_info.system}-{system_info.node}-{system_info.machine}\"\n    return str(uuid.uuid5(uuid.NAMESPACE_DNS, base))\n\n\nclass RingApiClient:\n    \"\"\"\n    Client for interacting with the Ring API.\n    \n    Handles authentication, token refresh, and API requests with retry logic.\n    \"\"\"\n    \n    def __init__(self, refresh_token: str = None, logger=None):\n        \"\"\"\n        Initialize the Ring API client.\n        \n        Args:\n            refresh_token: The OAuth refresh token for authentication\n            logger: Logger instance for logging messages\n        \"\"\"\n        self.refresh_token = refresh_token\n        self.access_token = None\n        self.token_expiration = None\n        self.hardware_id = generate_hardware_id()\n        self.logger = logger or logging.getLogger(\"ring_api\")\n    \n    def authenticate(self) -> Dict[str, Any]:\n        \"\"\"\n        Authenticate with the Ring API using refresh token.\n        \n        Returns:\n            Authentication response data\n            \n        Raises:\n            ToolError: If authentication fails\n        \"\"\"\n        headers = {\n            \"hardware_id\": self.hardware_id,\n            \"2fa-support\": \"true\",\n            \"User-Agent\": \"android:com.ringapp\",\n        }\n        \n        data = {\n            \"client_id\": \"ring_official_android\",\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": self.refresh_token,\n            \"scope\": \"client\",\n        }\n        \n        try:\n            response = requests.post(AUTH_URL, headers=headers, json=data)\n            response.raise_for_status()\n            auth_data = response.json()\n            \n            # Store authentication data\n            self.access_token = auth_data[\"access_token\"]\n            \n            # Calculate token expiration (subtract 60 seconds for safety)\n            expires_in = auth_data.get(\"expires_in\", 3600) - 60\n            self.token_expiration = datetime.now() + timedelta(seconds=expires_in)\n            \n            # Return the auth data (but don't update the refresh token as it's persistent)\n            return auth_data\n            \n        except requests.exceptions.RequestException as e:\n            raise ToolError(\n                f\"Authentication failed: {str(e)}\",\n                ErrorCode.API_AUTHENTICATION_ERROR,\n                {\"error\": str(e)}\n            )\n            \n    def is_token_valid(self) -> bool:\n        \"\"\"\n        Check if the current access token is valid.\n        \n        Returns:\n            True if the token is valid, False otherwise\n        \"\"\"\n        return (\n            self.access_token is not None and\n            self.token_expiration is not None and\n            datetime.now() < self.token_expiration\n        )\n    \n    def ensure_auth(self) -> None:\n        \"\"\"\n        Ensure that authentication is valid before making API requests.\n        \n        Raises:\n            ToolError: If authentication fails\n        \"\"\"\n        if not self.is_token_valid():\n            if not self.refresh_token:\n                raise ToolError(\n                    \"No refresh token available for authentication\",\n                    ErrorCode.API_AUTHENTICATION_ERROR\n                )\n                \n            self.authenticate()\n    \n    def request(self, method: str, url: str, **kwargs) -> Any:\n        \"\"\"\n        Make an authenticated request to the Ring API with retry logic.\n        \n        Args:\n            method: HTTP method (GET, POST, etc.)\n            url: API endpoint URL\n            **kwargs: Additional request parameters\n            \n        Returns:\n            Response data\n            \n        Raises:\n            ToolError: If the request fails after retries\n        \"\"\"\n        self.ensure_auth()\n        \n        # Prepare request\n        headers = kwargs.pop(\"headers\", {})\n        headers.update({\n            \"Authorization\": f\"Bearer {self.access_token}\",\n            \"hardware_id\": self.hardware_id,\n            \"User-Agent\": \"android:com.ringapp\",\n        })\n        \n        # Add content type for requests with body\n        if \"json\" in kwargs:\n            headers.update({\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/json\",\n            })\n            \n        # Prepare for retries\n        max_retries = 3\n        retry_count = 0\n        backoff_factor = 2  # Exponential backoff\n        \n        while retry_count < max_retries:\n            try:\n                response = requests.request(\n                    method, \n                    url, \n                    headers=headers, \n                    **kwargs\n                )\n                \n                # Check for auth errors\n                if response.status_code == 401:\n                    # Token might be expired, refresh and retry\n                    self.authenticate()\n                    headers[\"Authorization\"] = f\"Bearer {self.access_token}\"\n                    retry_count += 1\n                    continue\n                    \n                response.raise_for_status()\n                \n                # Try to parse JSON response\n                try:\n                    return response.json()\n                except ValueError:\n                    # Not JSON, return text\n                    return response.text\n                    \n            except requests.exceptions.RequestException as e:\n                retry_count += 1\n                \n                # Check if we should retry\n                if retry_count >= max_retries:\n                    raise ToolError(\n                        f\"Request failed after {max_retries} attempts: {str(e)}\",\n                        ErrorCode.TOOL_EXECUTION_ERROR,\n                        {\"error\": str(e), \"url\": url}\n                    )\n                \n                # Exponential backoff\n                wait_time = backoff_factor ** retry_count\n                self.logger.warning(\n                    f\"Request failed, retrying in {wait_time} seconds... (Attempt {retry_count}/{max_retries})\"\n                )\n                time.sleep(wait_time)\n    \n    def get_locations(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get all available Ring locations.\n        \n        Returns:\n            List of location data dictionaries\n            \n        Raises:\n            ToolError: If the request fails\n        \"\"\"\n        url = urljoin(DEVICE_API_BASE_URL, \"locations\")\n        response = self.request(\"GET\", url)\n        \n        if \"user_locations\" not in response:\n            raise ToolError(\n                \"Failed to retrieve locations: Unexpected response format\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"response\": response}\n            )\n            \n        return response[\"user_locations\"]\n    \n    def get_devices(self) -> Dict[str, Any]:\n        \"\"\"\n        Get all devices from the Ring account.\n        \n        Returns:\n            Dictionary containing device data\n            \n        Raises:\n            ToolError: If the request fails\n        \"\"\"\n        url = urljoin(CLIENT_API_BASE_URL, \"ring_devices\")\n        return self.request(\"GET\", url)\n    \n    def get_location_devices(self, location_id: str) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"\n        Get all devices for a specific location.\n        \n        Args:\n            location_id: The ID of the location to get devices for\n            \n        Returns:\n            Dictionary containing device data for the location\n            \n        Raises:\n            ToolError: If the request fails\n        \"\"\"\n        # First get all devices\n        all_devices = self.get_devices()\n        \n        # Then filter by location\n        location_devices = {\n            \"doorbots\": [],\n            \"chimes\": [],\n            \"stickup_cams\": [],\n            \"base_stations\": [],\n            \"beams_bridges\": [],\n            \"other\": []\n        }\n        \n        # Extract device categories from response\n        for category in location_devices:\n            if category in all_devices:\n                location_devices[category] = [\n                    device for device in all_devices[category]\n                    if device.get(\"location_id\") == location_id\n                ]\n                \n        return location_devices\n    \n    def get_security_panel_device(self, location_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get the security panel device for a location.\n        \n        Args:\n            location_id: ID of the location\n            \n        Returns:\n            Security panel device data\n            \n        Raises:\n            ToolError: If no security panel is found\n        \"\"\"\n        # Get all devices for the location\n        devices = self.get_location_devices(location_id)\n        \n        # Look for security panel in base stations\n        for device in devices.get(\"base_stations\", []):\n            if device.get(\"kind\") == \"security-panel\":\n                return device\n        \n        # If no security panel found, raise error\n        raise ToolError(\n            f\"Could not find a security panel for location {location_id}\",\n            ErrorCode.TOOL_EXECUTION_ERROR,\n            {\"location_id\": location_id}\n        )\n    \n    def get_alarm_mode(self, location_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get the current alarm mode for a location.\n        \n        Args:\n            location_id: The ID of the location\n            \n        Returns:\n            Alarm mode data including the current mode\n            \n        Raises:\n            ToolError: If the request fails or no security panel is found\n        \"\"\"\n        try:\n            # Get the security panel device for this location\n            security_panel = self.get_security_panel_device(location_id)\n            \n            # Log the entire security panel data for debugging\n            self.logger.info(f\"Security panel data: {json.dumps(security_panel, indent=2)}\")\n            \n            # Extract mode from device data\n            mode = security_panel.get(\"mode\", \"unknown\")\n            self.logger.info(f\"Extracted mode from security panel: {mode}\")\n            \n            # Return structured response\n            return {\"mode\": mode}\n            \n        except Exception as e:\n            self.logger.warning(f\"Failed to get mode from security panel: {str(e)}\")\n            # Fallback to location mode endpoint as a last resort\n            try:\n                url = urljoin(APP_API_BASE_URL, f\"mode/location/{location_id}\")\n                self.logger.info(f\"Trying fallback location mode API: {url}\")\n                response = self.request(\"GET\", url)\n                self.logger.info(f\"Location mode API response: {json.dumps(response, indent=2)}\")\n                return response\n            except Exception as fallback_error:\n                self.logger.error(f\"Fallback location mode API also failed: {str(fallback_error)}\")\n                # If both methods fail, raise the original error\n                raise e\n    \n    def set_alarm_mode(self, location_id: str, mode: str) -> Dict[str, Any]:\n        \"\"\"\n        Set the alarm mode for a location.\n        \n        Args:\n            location_id: The ID of the location\n            mode: The mode to set (disarmed, home, away)\n            \n        Returns:\n            Response data\n            \n        Raises:\n            ToolError: If the request fails or the mode is invalid\n        \"\"\"\n        # Map mode names to Ring API values\n        mode_map = {\n            \"disarmed\": \"none\",\n            \"home\": \"some\",\n            \"away\": \"all\"\n        }\n        \n        if mode not in mode_map:\n            raise ToolError(\n                f\"Invalid alarm mode: {mode}. Must be one of: disarmed, home, away\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"valid_modes\": list(mode_map.keys())}\n            )\n            \n        ring_mode = mode_map[mode]\n        \n        try:\n            # Approach 1: Get the security panel device to send the command directly\n            # This matches TypeScript implementation in location.ts:setAlarmMode\n            security_panel = self.get_security_panel_device(location_id)\n            device_id = security_panel.get(\"id\")\n            \n            if device_id:\n                # Send command to the security panel\n                # Based on sendCommandToSecurityPanel and sendCommand methods in TypeScript\n                url = urljoin(CLIENT_API_BASE_URL, f\"devices/{device_id}\")\n                \n                # This payload structure matches the TypeScript implementation\n                # where it uses security-panel.switch-mode command\n                data = {\n                    \"command\": {\n                        \"v1\": [\n                            {\n                                \"commandType\": \"security-panel.switch-mode\",\n                                \"data\": {\n                                    \"mode\": ring_mode,\n                                    \"bypass\": []\n                                }\n                            }\n                        ]\n                    }\n                }\n                \n                self.logger.info(f\"Setting mode to {ring_mode} via security panel device API\")\n                return self.request(\"PUT\", url, json=data)\n        except Exception as e:\n            self.logger.warning(f\"Failed to set mode via security panel: {str(e)}\")\n            \n        # Approach 2: Use the location mode API (matches TypeScript setLocationMode)\n        try:\n            # First get the current mode to see the response format\n            url = urljoin(APP_API_BASE_URL, f\"mode/location/{location_id}\")\n            current_mode_response = self.request(\"GET\", url)\n            self.logger.info(f\"Current mode response: {json.dumps(current_mode_response, indent=2)}\")\n            \n            # Extract securityStatus to include it in our request\n            security_status = current_mode_response.get(\"securityStatus\", {})\n            timestamp = int(time.time() * 1000)  # Current time in milliseconds\n            \n            # Prepare data with similar format to what the API expects\n            data = {\n                \"mode\": ring_mode,\n                \"lastUpdateTimeMS\": timestamp\n            }\n            \n            # If there's security status info, include it\n            if security_status:\n                security_status[\"md\"] = ring_mode  # Update mode in security status\n                security_status[\"lu\"] = timestamp  # Update timestamp\n                data[\"securityStatus\"] = security_status\n            \n            self.logger.info(f\"Setting mode to {ring_mode} via location mode API with payload: {json.dumps(data, indent=2)}\")\n            return self.request(\"POST\", url, json=data)\n        except Exception as e:\n            self.logger.warning(f\"Failed to set mode via location mode API: {str(e)}\")\n            \n            # Try an alternative approach with simpler payload\n            try:\n                url = urljoin(APP_API_BASE_URL, f\"mode/location/{location_id}\")\n                data = {\"mode\": ring_mode}\n                self.logger.info(f\"Trying simplified payload: {json.dumps(data, indent=2)}\")\n                return self.request(\"POST\", url, json=data)\n            except Exception as e2:\n                self.logger.warning(f\"Failed with simplified payload: {str(e2)}\")\n                \n                # Try one more API format\n                try:\n                    url = urljoin(APP_API_BASE_URL, f\"locations/{location_id}/mode\")\n                    data = {\"mode\": ring_mode}\n                    self.logger.info(f\"Trying locations mode API: {json.dumps(data, indent=2)}\")\n                    return self.request(\"POST\", url, json=data)\n                except Exception as e3:\n                    self.logger.warning(f\"Failed with locations mode API: {str(e3)}\")\n                    \n                    raise ToolError(\n                        f\"Failed to set alarm mode to {mode}. All approaches failed.\",\n                        ErrorCode.TOOL_EXECUTION_ERROR,\n                        {\"location_id\": location_id, \"requested_mode\": mode, \"error\": str(e)}\n                    )\n    \n    def verify_alarm_mode(self, location_id: str, expected_mode: str, max_attempts: int = 3) -> bool:\n        \"\"\"\n        Verify that the alarm mode has been set correctly.\n        \n        Args:\n            location_id: The ID of the location\n            expected_mode: The expected mode (disarmed, home, away)\n            max_attempts: Maximum number of verification attempts\n            \n        Returns:\n            True if the mode matches, False otherwise\n        \"\"\"\n        # Map mode names to Ring API values\n        mode_map = {\n            \"disarmed\": \"none\",\n            \"home\": \"some\",\n            \"away\": \"all\"\n        }\n        \n        ring_mode = mode_map.get(expected_mode, \"\")\n        self.logger.info(f\"Verifying alarm mode - expecting: {expected_mode} (API value: {ring_mode})\")\n        \n        # Try multiple times with a delay between attempts\n        # This accounts for any delay in the mode change propagating\n        for attempt in range(max_attempts):\n            try:\n                # Get current mode\n                self.logger.info(f\"Verification attempt {attempt+1}/{max_attempts}\")\n                current_mode_data = self.get_alarm_mode(location_id)\n                self.logger.info(f\"Current mode data: {json.dumps(current_mode_data, indent=2)}\")\n                \n                # Extract current mode from response - try both direct key and nested structure\n                current_mode = \"\"\n                if isinstance(current_mode_data, dict):\n                    current_mode = current_mode_data.get(\"mode\", \"\")\n                \n                self.logger.info(f\"Extracted current mode: {current_mode}, Expected: {ring_mode}\")\n                \n                # Check if mode matches expected value (case insensitive)\n                # Also try matching the friendly name directly\n                if (current_mode.lower() == ring_mode.lower() or \n                    current_mode.lower() == expected_mode.lower()):\n                    self.logger.info(f\"Mode verified successfully as {current_mode}\")\n                    return True\n                \n                self.logger.warning(f\"Mode verification failed. Got: {current_mode}, Expected: {ring_mode}\")\n                    \n                # If not on the last attempt, wait before trying again\n                if attempt < max_attempts - 1:\n                    wait_time = 2 ** attempt\n                    self.logger.info(f\"Waiting {wait_time} seconds before retrying...\")\n                    time.sleep(wait_time)  # Exponential backoff\n                    \n            except Exception as e:\n                self.logger.warning(f\"Error verifying alarm mode (attempt {attempt+1}): {str(e)}\")\n                \n                # If not on the last attempt, wait before trying again\n                if attempt < max_attempts - 1:\n                    wait_time = 2 ** attempt\n                    self.logger.info(f\"Error occurred. Waiting {wait_time} seconds before retrying...\")\n                    time.sleep(wait_time)\n        \n        self.logger.error(f\"Failed to verify alarm mode after {max_attempts} attempts\")\n        return False\n\n\nclass RingAuthenticator:\n    \"\"\"\n    Handles Ring authentication and token management.\n    \"\"\"\n    \n    def __init__(self, data_dir: str, logger=None):\n        \"\"\"\n        Initialize the authenticator.\n        \n        Args:\n            data_dir: Directory to store authentication data\n            logger: Logger instance for logging messages\n        \"\"\"\n        self.data_dir = data_dir\n        self.token_path = os.path.join(data_dir, \"token.json\")\n        self.logger = logger or logging.getLogger(\"ring_auth\")\n        \n        # Create data directory if it doesn't exist\n        os.makedirs(data_dir, exist_ok=True)\n    \n    def load_token(self) -> Optional[str]:\n        \"\"\"\n        Load the refresh token from the token file or environment.\n        \n        Returns:\n            Refresh token if available, None otherwise\n        \"\"\"\n        # Try loading from environment first\n        refresh_token = os.environ.get(\"RING_API_TOKEN\")\n        if refresh_token:\n            return refresh_token\n            \n        # Then try the token file\n        if os.path.exists(self.token_path):\n            try:\n                with open(self.token_path, \"r\") as f:\n                    token_data = json.load(f)\n                    return token_data.get(\"refresh_token\")\n            except (json.JSONDecodeError, IOError):\n                return None\n                \n        return None\n    \n    def save_token(self, token_data: Dict[str, Any]) -> None:\n        \"\"\"\n        Save token data to the token file.\n        \n        Args:\n            token_data: Token data to save\n        \"\"\"\n        with open(self.token_path, \"w\") as f:\n            json.dump(token_data, f, indent=2)\n            \n    def authenticate_interactive(self) -> str:\n        \"\"\"\n        Perform interactive authentication to get a refresh token.\n        \n        Returns:\n            New refresh token\n            \n        Raises:\n            ToolError: If authentication fails\n        \"\"\"\n        print(\"\\n*** Ring Interactive Authentication ***\\n\")\n        print(\"This process will generate a refresh token for the Ring API.\")\n        print(\"Please follow the steps carefully:\\n\")\n        \n        print(\"1. Go to https://oauth.ring.com/oauth/authorize?client_id=ring_official_android&response_type=code&scope=client\")\n        print(\"2. Log in with your Ring credentials\")\n        print(\"3. After logging in, you'll be redirected to a URL that starts with 'com.ringapp://'\")\n        print(\"4. Copy the entire URL and paste it below\\n\")\n        \n        auth_url = input(\"Paste the URL here: \").strip()\n        \n        # Extract the code from the URL\n        match = re.search(r\"code=([^&]+)\", auth_url)\n        if not match:\n            raise ToolError(\n                \"Invalid authentication URL: Could not find authorization code\",\n                ErrorCode.API_AUTHENTICATION_ERROR\n            )\n            \n        auth_code = match.group(1)\n        \n        # Exchange code for token\n        headers = {\n            \"hardware_id\": generate_hardware_id(),\n            \"User-Agent\": \"android:com.ringapp\",\n        }\n        \n        data = {\n            \"client_id\": \"ring_official_android\",\n            \"grant_type\": \"authorization_code\",\n            \"code\": auth_code,\n        }\n        \n        try:\n            response = requests.post(AUTH_URL, headers=headers, json=data)\n            response.raise_for_status()\n            auth_data = response.json()\n            \n            # Save the token data\n            self.save_token(auth_data)\n            \n            # Output the token for the user to save to .env\n            print(\"\\nAuthentication successful!\")\n            print(f\"\\nYour refresh token is: {auth_data['refresh_token']}\")\n            print(\"\\nSave this to your .env file as RING_API_TOKEN=<token>\")\n            \n            return auth_data[\"refresh_token\"]\n            \n        except requests.exceptions.RequestException as e:\n            raise ToolError(\n                f\"Authentication failed: {str(e)}\",\n                ErrorCode.API_AUTHENTICATION_ERROR,\n                {\"error\": str(e)}\n            )\n\n\nclass RingTool(Tool):\n    \"\"\"\n    Tool for interacting with Ring security devices and systems.\n    \n    This tool provides functionality to:\n    1. List Ring locations and devices\n    2. Check alarm status\n    3. Arm and disarm security systems\n    \"\"\"\n    \n    name = \"ring_tool\"\n    description = \"\"\"Controls Ring security devices with comprehensive management capabilities.\n\nThis tool enables interaction with Ring security systems including:\n\n1. Device and Location Management:\n   - 'list_locations': Retrieve all available Ring locations\n   - 'list_devices': Retrieve all devices for a specific location\n   - 'get_device_info': Get detailed status and capabilities of a specific device\n\n2. Alarm System Control:\n   - 'get_alarm_mode': Check current mode of alarm system (disarmed, home, away)\n   - 'set_alarm_mode': Set alarm mode (disarmed, home, away)\n\nUse this tool whenever you need to check the status of or control Ring security devices.\nThe tool requires authentication with a Ring account through a refresh token.\n\"\"\"\n    usage_examples = [\n        {\n            \"input\": {\n                \"operation\": \"list_locations\"\n            },\n            \"output\": {\n                \"locations\": [\n                    {\n                        \"id\": \"488e4800-fcde-4493-969b-d1a06f683102\",\n                        \"name\": \"Home\",\n                        \"timezone\": \"America/New_York\"\n                    }\n                ]\n            }\n        },\n        {\n            \"input\": {\n                \"operation\": \"list_devices\",\n                \"location_id\": \"488e4800-fcde-4493-969b-d1a06f683102\"\n            },\n            \"output\": {\n                \"devices\": [\n                    {\n                        \"id\": \"5ab22d5c-f456-4d19-8f55-3491face68d9\",\n                        \"name\": \"Front Door\",\n                        \"type\": \"doorbell\"\n                    }\n                ]\n            }\n        },\n        {\n            \"input\": {\n                \"operation\": \"set_alarm_mode\",\n                \"location_id\": \"488e4800-fcde-4493-969b-d1a06f683102\",\n                \"mode\": \"home\"\n            },\n            \"output\": {\n                \"success\": True,\n                \"message\": \"Alarm system armed in home mode\",\n                \"location\": \"Home\"\n            }\n        }\n    ]\n    \n    def __init__(self):\n        \"\"\"Initialize the Ring tool.\"\"\"\n        super().__init__()\n        \n        # Set up data directory\n        self.data_dir = os.path.join(\"data\", \"tools\", \"ring_tool\")\n        os.makedirs(self.data_dir, exist_ok=True)\n        \n        # Initialize authentication and API client\n        self.authenticator = RingAuthenticator(self.data_dir, self.logger)\n        self.refresh_token = self.authenticator.load_token()\n        self.api_client = None\n    \n    def _get_api_client(self) -> RingApiClient:\n        \"\"\"\n        Get an initialized API client.\n        \n        Returns:\n            RingApiClient instance\n            \n        Raises:\n            ToolError: If authentication fails\n        \"\"\"\n        if self.api_client is None:\n            if not self.refresh_token:\n                # Attempt interactive authentication\n                self.refresh_token = self.authenticator.authenticate_interactive()\n                \n            self.api_client = RingApiClient(self.refresh_token, self.logger)\n            \n        return self.api_client\n    \n    def _list_locations(self) -> Dict[str, Any]:\n        \"\"\"\n        List all available Ring locations.\n        \n        Returns:\n            Dictionary containing locations data\n        \"\"\"\n        client = self._get_api_client()\n        locations = client.get_locations()\n        \n        # Format location data for output\n        formatted_locations = []\n        for location in locations:\n            formatted_locations.append({\n                \"id\": location[\"location_id\"],\n                \"name\": location[\"name\"],\n                \"address\": location.get(\"address\", {}).get(\"address1\", \"\"),\n                \"timezone\": location.get(\"timezone\", \"\")\n            })\n            \n        return {\"locations\": formatted_locations}\n    \n    def _list_devices(self, location_id: str) -> Dict[str, Any]:\n        \"\"\"\n        List all devices for a specific location.\n        \n        Args:\n            location_id: The ID of the location to get devices for\n            \n        Returns:\n            Dictionary containing devices data\n        \"\"\"\n        client = self._get_api_client()\n        devices_by_type = client.get_location_devices(location_id)\n        \n        # Combine all device types\n        all_devices = []\n        \n        # Process doorbots (doorbells)\n        for device in devices_by_type.get(\"doorbots\", []):\n            all_devices.append({\n                \"id\": str(device[\"id\"]),\n                \"name\": device.get(\"description\", \"Doorbell\"),\n                \"type\": \"doorbell\",\n                \"battery_level\": device.get(\"battery_life\"),\n                \"firmware\": device.get(\"firmware_version\")\n            })\n            \n        # Process cameras\n        for device in devices_by_type.get(\"stickup_cams\", []):\n            all_devices.append({\n                \"id\": str(device[\"id\"]),\n                \"name\": device.get(\"description\", \"Camera\"),\n                \"type\": \"camera\",\n                \"battery_level\": device.get(\"battery_life\"),\n                \"firmware\": device.get(\"firmware_version\")\n            })\n            \n        # Process base stations and alarm devices\n        for device in devices_by_type.get(\"base_stations\", []):\n            device_type = \"alarm_base_station\"\n            if device.get(\"kind\") == \"security-panel\":\n                device_type = \"security_panel\"\n                \n            all_devices.append({\n                \"id\": str(device[\"id\"]),\n                \"name\": device.get(\"description\", \"Alarm Device\"),\n                \"type\": device_type,\n                \"firmware\": device.get(\"firmware_version\")\n            })\n            \n        return {\"devices\": all_devices}\n    \n    def _get_device_info(self, location_id: str, device_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific device.\n        \n        Args:\n            location_id: The ID of the location the device belongs to\n            device_id: The ID of the device to get info for\n            \n        Returns:\n            Dictionary containing device information\n            \n        Raises:\n            ToolError: If the device is not found\n        \"\"\"\n        client = self._get_api_client()\n        \n        # Get all devices for the location\n        devices_by_type = client.get_location_devices(location_id)\n        \n        # Search for the device in all categories\n        for category, devices in devices_by_type.items():\n            for device in devices:\n                if str(device.get(\"id\")) == device_id:\n                    return device\n                    \n        raise ToolError(\n            f\"Device not found with ID {device_id} in location {location_id}\",\n            ErrorCode.TOOL_EXECUTION_ERROR,\n            {\"location_id\": location_id, \"device_id\": device_id}\n        )\n    \n    def _get_alarm_mode(self, location_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get the current mode of the alarm system.\n        \n        Args:\n            location_id: The ID of the location to get alarm mode for\n            \n        Returns:\n            Dictionary containing alarm mode information\n        \"\"\"\n        client = self._get_api_client()\n        \n        # Get the alarm mode\n        self.logger.info(f\"Requesting alarm mode for location {location_id}\")\n        mode_data = client.get_alarm_mode(location_id)\n        self.logger.info(f\"Raw alarm mode data: {json.dumps(mode_data, indent=2)}\")\n        \n        # Get location information\n        locations = client.get_locations()\n        location_name = \"Unknown\"\n        \n        for location in locations:\n            if location[\"location_id\"] == location_id:\n                location_name = location[\"name\"]\n                break\n        \n        # Map API mode to user-friendly mode\n        mode_map = {\n            \"none\": \"disarmed\",\n            \"some\": \"home\",\n            \"all\": \"away\"\n        }\n        \n        # Check different possible mode formats from the response\n        current_mode = \"unknown\"\n        if isinstance(mode_data, dict):\n            # Try different possible keys where mode might be stored\n            if \"mode\" in mode_data:\n                current_mode = mode_data[\"mode\"]\n            elif \"state\" in mode_data:\n                current_mode = mode_data[\"state\"]\n            \n        self.logger.info(f\"Extracted current_mode: {current_mode}\")\n        friendly_mode = mode_map.get(current_mode, current_mode)\n        self.logger.info(f\"Mapped to friendly_mode: {friendly_mode}\")\n        \n        response = {\n            \"location_name\": location_name,\n            \"mode\": friendly_mode,\n            \"raw_mode\": current_mode\n        }\n        \n        self.logger.info(f\"Final alarm mode response: {json.dumps(response, indent=2)}\")\n        return response\n    \n    def _set_alarm_mode(self, location_id: str, mode: str) -> Dict[str, Any]:\n        \"\"\"\n        Set the mode of the alarm system.\n        \n        Args:\n            location_id: The ID of the location to set alarm mode for\n            mode: The mode to set (disarmed, home, away)\n            \n        Returns:\n            Dictionary containing operation result\n        \"\"\"\n        client = self._get_api_client()\n        \n        # Get location information\n        locations = client.get_locations()\n        location_name = \"Unknown\"\n        \n        for location in locations:\n            if location[\"location_id\"] == location_id:\n                location_name = location[\"name\"]\n                break\n        \n        # Get current mode before changing\n        current_mode_data = client.get_alarm_mode(location_id)\n        mode_map = {\n            \"none\": \"disarmed\",\n            \"some\": \"home\",\n            \"all\": \"away\"\n        }\n        previous_mode = mode_map.get(current_mode_data.get(\"mode\", \"unknown\"), \"unknown\")\n        \n        # Set the alarm mode\n        client.set_alarm_mode(location_id, mode)\n        \n        # Verify the mode was set correctly\n        success = client.verify_alarm_mode(location_id, mode)\n        \n        if not success:\n            raise ToolError(\n                f\"Failed to set alarm mode to {mode}. The mode was not changed.\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"location_id\": location_id, \"requested_mode\": mode}\n            )\n        \n        # Mode descriptions for messaging\n        mode_descriptions = {\n            \"disarmed\": \"disarmed\",\n            \"home\": \"armed in home mode\",\n            \"away\": \"armed in away mode\"\n        }\n        \n        return {\n            \"success\": True,\n            \"message\": f\"Alarm system {mode_descriptions[mode]}\",\n            \"location\": location_name,\n            \"previous_mode\": previous_mode,\n            \"current_mode\": mode\n        }\n    \n    def run(\n        self,\n        operation: str,\n        location_id: Optional[str] = None,\n        device_id: Optional[str] = None,\n        mode: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute a Ring device operation.\n        \n        Args:\n            operation: Operation to perform (list_locations, list_devices, etc.)\n            location_id: The ID of the location to operate on\n            device_id: The ID of the device to operate on\n            mode: Mode to set (for set_alarm_mode operation)\n            \n        Returns:\n            Dictionary with operation result\n            \n        Raises:\n            ToolError: If operation fails or parameters are invalid\n        \"\"\"\n        with error_context(\n            component_name=self.name,\n            operation=f\"executing {operation}\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger\n        ):\n            # Run the appropriate operation\n            if operation == \"list_locations\":\n                return self._list_locations()\n                \n            elif operation == \"list_devices\":\n                if not location_id:\n                    raise ToolError(\n                        \"location_id parameter is required for list_devices operation\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                return self._list_devices(location_id)\n                \n            elif operation == \"get_device_info\":\n                if not location_id or not device_id:\n                    raise ToolError(\n                        \"location_id and device_id parameters are required for get_device_info operation\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                return self._get_device_info(location_id, device_id)\n                \n            elif operation == \"get_alarm_mode\":\n                if not location_id:\n                    raise ToolError(\n                        \"location_id parameter is required for get_alarm_mode operation\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                return self._get_alarm_mode(location_id)\n                \n            elif operation == \"set_alarm_mode\":\n                if not location_id:\n                    raise ToolError(\n                        \"location_id parameter is required for set_alarm_mode operation\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                if not mode:\n                    raise ToolError(\n                        \"mode parameter is required for set_alarm_mode operation\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                if mode not in [\"disarmed\", \"home\", \"away\"]:\n                    raise ToolError(\n                        f\"Invalid alarm mode: {mode}. Must be one of: disarmed, home, away\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                return self._set_alarm_mode(location_id, mode)\n                \n            else:\n                valid_operations = [\n                    \"list_locations\", \n                    \"list_devices\", \n                    \"get_device_info\",\n                    \"get_alarm_mode\", \n                    \"set_alarm_mode\"\n                ]\n                \n                raise ToolError(\n                    f\"Unknown operation: {operation}. Valid operations are: {', '.join(valid_operations)}\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n\n# #BOOKMARK: Future enhancement - WebSocket connections and push notifications\n# These features would need to be implemented for real-time status updates and notifications,\n# but are not necessary for the basic security system functionality implemented here.",
  "description": "A tool for interacting with Ring security systems, allowing users to control alarm systems, check device status, and manage locations.",
  "operations": [
    {
      "name": "list_locations",
      "description": "Retrieves all available Ring locations associated with the authenticated account.",
      "required_parameters": [
        {
          "name": "operation",
          "type": "string",
          "description": "Must be set to 'list_locations' to execute this operation"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "list_devices",
      "description": "Retrieves all devices for a specific Ring location, including doorbells, cameras, and alarm components.",
      "required_parameters": [
        {
          "name": "operation",
          "type": "string",
          "description": "Must be set to 'list_devices' to execute this operation"
        },
        {
          "name": "location_id",
          "type": "string",
          "description": "The ID of the location to get devices for"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "get_device_info",
      "description": "Retrieves detailed information about a specific Ring device.",
      "required_parameters": [
        {
          "name": "operation",
          "type": "string",
          "description": "Must be set to 'get_device_info' to execute this operation"
        },
        {
          "name": "location_id",
          "type": "string",
          "description": "The ID of the location the device belongs to"
        },
        {
          "name": "device_id",
          "type": "string",
          "description": "The ID of the device to get information for"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "get_alarm_mode",
      "description": "Checks the current mode of the Ring alarm system (disarmed, home, or away).",
      "required_parameters": [
        {
          "name": "operation",
          "type": "string",
          "description": "Must be set to 'get_alarm_mode' to execute this operation"
        },
        {
          "name": "location_id",
          "type": "string",
          "description": "The ID of the location to get alarm mode for"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "set_alarm_mode",
      "description": "Sets the mode of the Ring alarm system to disarmed, home, or away.",
      "required_parameters": [
        {
          "name": "operation",
          "type": "string",
          "description": "Must be set to 'set_alarm_mode' to execute this operation"
        },
        {
          "name": "location_id",
          "type": "string",
          "description": "The ID of the location to set alarm mode for"
        },
        {
          "name": "mode",
          "type": "string",
          "description": "The mode to set (must be one of: disarmed, home, away)"
        }
      ],
      "optional_parameters": []
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}