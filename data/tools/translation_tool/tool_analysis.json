{
  "tool_name": "translation_tool",
  "tool_code": "import logging\nfrom typing import Dict, Any, Optional\n\nfrom tools.repo import Tool\nfrom errors import ErrorCode, error_context, ToolError\nfrom api.llm_bridge import LLMBridge\n\n\nclass TranslationTool(Tool):\n    \"\"\"\n    Translates communicative intent between languages with context awareness.\n    \n    This tool conveys semantic meaning and intention in a culturally appropriate way,\n    taking into account contextual information that might affect the translation.\n    It generates natural-sounding expressions that native speakers would use in the\n    given context and situation.\n    \n    Uses Claude 3.5 Sonnet model specifically for optimal translation quality.\n    \"\"\"\n    \n    name = \"translation_tool\"\n    description = \"\"\"\n    Translates communicative intent into different languages in a natural, culturally \n    appropriate way, considering provided context. Use this tool when users want to know \n    how to express something in another language with proper cultural and situational awareness.\n    \n    This tool does not perform word-for-word translation, but rather understands what \n    the user wants to communicate and produces natural phrasing that a native speaker \n    would use in the specific context. It adjusts for different formality levels, \n    social situations, and can provide pronunciation guides or cultural usage notes.\n    \n    Parameters:\n    - intent: The core message to translate (what you want to say/ask)\n    - target_language: The language to translate the intent into\n    - context: Additional background information that affects how the intent should be expressed\n    - formality_level: Level of formality (casual, neutral, formal, honorific) - defaults to neutral\n    - include_pronunciation: Whether to include a pronunciation guide - defaults to false\n    - include_cultural_notes: Whether to include cultural usage notes - defaults to false\n    \n    This tool is particularly useful for:\n    1. Preparing to communicate in foreign countries with proper social awareness\n    2. Learning culturally appropriate expressions for specific situations\n    3. Generating natural-sounding phrases beyond what simple translation tools provide\n    \n    The tool uses Claude 3.5 Sonnet specifically for optimal translation quality.\n    \"\"\"\n    \n    usage_examples = [\n        {\n            \"input\": {\n                \"intent\": \"where is the nearest grocery store\",\n                \"target_language\": \"Japanese\",\n                \"context\": \"I am a tourist and appear obviously foreign\",\n                \"formality_level\": \"polite\"\n            },\n            \"output\": {\n                \"translation\": \"\u4e00\u756a\u8fd1\u3044\u30b9\u30fc\u30d1\u30fc\u306f\u3069\u3053\u3067\u3059\u304b\uff1f\",\n                \"pronunciation\": \"Ichiban chikai suupaa wa doko desu ka?\",\n                \"cultural_notes\": \"Using polite form suitable for asking locals for directions as a foreigner\",\n                \"source_intent\": \"where is the nearest grocery store\",\n                \"target_language\": \"Japanese\"\n            }\n        }\n    ]\n    \n    def __init__(self, llm_bridge: LLMBridge):\n        \"\"\"\n        Initialize the translation tool.\n        \n        Args:\n            llm_bridge: LLMBridge instance for communicating with Claude\n        \"\"\"\n        super().__init__()\n        self.llm_bridge = llm_bridge\n        self.logger.info(\"Translation tool initialized\")\n        \n        # Supported formality levels\n        self.formality_levels = [\"casual\", \"neutral\", \"formal\", \"honorific\"]\n        \n        # Specify Sonnet model - will override default model from LLMBridge\n        self.sonnet_model = \"claude-3-5-sonnet-20240620\"\n        \n    def run(\n        self,\n        intent: str,\n        target_language: str,\n        context: Optional[str] = None,\n        formality_level: str = \"neutral\",\n        include_pronunciation: bool = False,\n        include_cultural_notes: bool = False\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Translate semantic intent into the target language with context awareness.\n        \n        Args:\n            intent: The core message to translate (what you want to say/ask)\n            target_language: The language to translate into\n            context: Additional background information that affects how the intent should be expressed\n            formality_level: Level of formality (casual, neutral, formal, honorific)\n            include_pronunciation: Whether to include a pronunciation guide\n            include_cultural_notes: Whether to include cultural usage notes\n            \n        Returns:\n            Dictionary containing translation and optional additional information\n            \n        Raises:\n            ToolError: If inputs are invalid or translation fails\n        \"\"\"\n        self.logger.info(f\"Translating intent to {target_language} with context using {self.sonnet_model}\")\n        \n        # Input validation using error_context\n        with error_context(\n            component_name=self.name,\n            operation=\"validating inputs\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_INVALID_INPUT,\n            logger=self.logger\n        ):\n            # Validate intent\n            if not intent or not isinstance(intent, str):\n                raise ToolError(\n                    \"Intent must be a non-empty string\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"provided_intent\": str(intent)}\n                )\n                \n            # Validate target language\n            if not target_language or not isinstance(target_language, str):\n                raise ToolError(\n                    \"Target language must be a non-empty string\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"provided_language\": str(target_language)}\n                )\n                \n            # Validate formality level\n            if formality_level not in self.formality_levels:\n                raise ToolError(\n                    f\"Invalid formality level: {formality_level}. Must be one of: {', '.join(self.formality_levels)}\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"provided_formality\": formality_level, \"valid_levels\": self.formality_levels}\n                )\n        \n        # Perform translation\n        with error_context(\n            component_name=self.name,\n            operation=\"translating content\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger\n        ):\n            # Generate system prompt\n            system_prompt = self._create_system_prompt(\n                target_language, \n                formality_level,\n                include_pronunciation,\n                include_cultural_notes\n            )\n            \n            # Create user message combining intent and context\n            user_message = self._format_user_message(intent, context)\n            \n            # Create message for Claude\n            messages = [\n                {\"role\": \"user\", \"content\": user_message}\n            ]\n            \n            # Make LLM call with explicit Sonnet model\n            try:\n                response = self.llm_bridge.generate_response(\n                    messages=messages,\n                    system_prompt=system_prompt,\n                    # Explicitly override model to use Sonnet\n                    model=self.sonnet_model,\n                    # Use lower temperature for more consistent translations\n                    temperature=0.3\n                )\n                \n                # Extract translation\n                translation_text = self.llm_bridge.extract_text_content(response)\n                \n                # Parse the response to separate translation from pronunciation/notes\n                result = self._parse_translation_response(\n                    translation_text, \n                    include_pronunciation,\n                    include_cultural_notes\n                )\n                \n                # Return results\n                return {\n                    \"translation\": result.get(\"translation\", \"\"),\n                    \"pronunciation\": result.get(\"pronunciation\", \"\") if include_pronunciation else \"\",\n                    \"cultural_notes\": result.get(\"cultural_notes\", \"\") if include_cultural_notes else \"\",\n                    \"source_intent\": intent,\n                    \"context\": context or \"\",\n                    \"target_language\": target_language,\n                    \"model_used\": self.sonnet_model\n                }\n            except Exception as e:\n                # If Sonnet fails, log the error and re-raise\n                self.logger.error(f\"Translation failed with Sonnet model: {str(e)}\")\n                raise ToolError(\n                    f\"Translation failed: {str(e)}\",\n                    ErrorCode.TOOL_EXECUTION_ERROR,\n                    {\"intent\": intent, \"target_language\": target_language}\n                )\n    \n    def _format_user_message(self, intent: str, context: Optional[str] = None) -> str:\n        \"\"\"\n        Format the user message with intent and optional context.\n        \n        Args:\n            intent: The core message to translate\n            context: Optional contextual information\n            \n        Returns:\n            Formatted message for the LLM\n        \"\"\"\n        if context:\n            return f\"INTENT: {intent}\\n\\nCONTEXT: {context}\"\n        else:\n            return f\"INTENT: {intent}\"\n    \n    def _create_system_prompt(\n        self, \n        target_language: str, \n        formality_level: str,\n        include_pronunciation: bool,\n        include_cultural_notes: bool\n    ) -> str:\n        \"\"\"\n        Create a system prompt for the translation request.\n        \n        Args:\n            target_language: Target language\n            formality_level: Formality level\n            include_pronunciation: Whether to include pronunciation\n            include_cultural_notes: Whether to include cultural notes\n            \n        Returns:\n            Formatted system prompt\n        \"\"\"\n        prompt = f\"\"\"\n        You are a cultural and linguistic translator skilled in conveying communicative intent across languages.\n\n        Your task is to translate the user's INTENT into {target_language} at a {formality_level} level of formality.\n        The user may also provide CONTEXT information that should inform how you translate the intent.\n\n        Guidelines:\n        1. Only translate the INTENT, not the CONTEXT\n        2. Use the CONTEXT to determine appropriate phrasing, formality adjustments, and cultural adaptations\n        3. Create a natural phrase that a native {target_language} speaker would use in the given situation\n        4. Consider social dynamics, speaker/listener relationship, and situational appropriateness\n        5. Do not translate word-for-word; focus on conveying the communicative goal naturally\n\n        For example, translating \"where is the bathroom\" would differ if the context is:\n        - \"I am at a formal business dinner\" (more polite/formal expression)\n        - \"I am at a friend's house\" (more casual expression)\n        - \"I am a tourist asking a stranger\" (might use simpler terms or include \"excuse me\")\n\n        Format your response as follows:\n        \"\"\"\n        \n        prompt += f\"\\nTRANSLATION:\\n[The translated intent in {target_language}]\"\n        \n        if include_pronunciation:\n            prompt += \"\\n\\nPRONUNCIATION:\\n[Simple pronunciation guide for non-native speakers]\"\n            \n        if include_cultural_notes:\n            prompt += \"\\n\\nCULTURAL NOTES:\\n[Brief cultural context or usage notes relevant to this phrase]\"\n            \n        return prompt\n        \n    def _parse_translation_response(\n        self, \n        response_text: str,\n        include_pronunciation: bool,\n        include_cultural_notes: bool\n    ) -> Dict[str, str]:\n        \"\"\"\n        Parse the response from Claude into structured data.\n        \n        Args:\n            response_text: Raw text response from Claude\n            include_pronunciation: Whether pronunciation was requested\n            include_cultural_notes: Whether cultural notes were requested\n            \n        Returns:\n            Dictionary containing parsed translation components\n        \"\"\"\n        result = {\n            \"translation\": \"\",\n            \"pronunciation\": \"\",\n            \"cultural_notes\": \"\"\n        }\n        \n        # Simple parsing logic - handles section headers followed by content\n        lines = response_text.split(\"\\n\")\n        current_section = None\n        \n        for line in lines:\n            line = line.strip()\n            \n            if not line:\n                continue\n            \n            if \"TRANSLATION:\" in line.upper():\n                current_section = \"translation\"\n                # Skip this header line\n                continue\n            elif \"PRONUNCIATION:\" in line.upper():\n                current_section = \"pronunciation\"\n                continue\n            elif \"CULTURAL NOTES:\" in line.upper():\n                current_section = \"cultural_notes\"\n                continue\n            \n            # If we have a current section and the line is not empty, add to that section\n            if current_section and line:\n                if result[current_section]:\n                    result[current_section] += \"\\n\" + line\n                else:\n                    result[current_section] = line\n        \n        # If parsing fails, just use the whole response as the translation\n        if not result[\"translation\"]:\n            result[\"translation\"] = response_text.strip()\n            \n        return result",
  "description": "Translates communicative intent between languages with context awareness, conveying semantic meaning and intention in a culturally appropriate way rather than performing word-for-word translation.",
  "operations": [
    {
      "name": "run",
      "description": "Translates semantic intent into the target language with context awareness, producing natural phrasing that a native speaker would use in the specific context.",
      "required_parameters": [
        {
          "name": "intent",
          "type": "str",
          "description": "The core message to translate (what you want to say/ask)"
        },
        {
          "name": "target_language",
          "type": "str",
          "description": "The language to translate the intent into"
        }
      ],
      "optional_parameters": [
        {
          "name": "context",
          "type": "str",
          "description": "Additional background information that affects how the intent should be expressed",
          "default": "None"
        },
        {
          "name": "formality_level",
          "type": "str",
          "description": "Level of formality (casual, neutral, formal, honorific)",
          "default": "neutral"
        },
        {
          "name": "include_pronunciation",
          "type": "bool",
          "description": "Whether to include a pronunciation guide",
          "default": "False"
        },
        {
          "name": "include_cultural_notes",
          "type": "bool",
          "description": "Whether to include cultural usage notes",
          "default": "False"
        }
      ]
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}