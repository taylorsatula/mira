{
  "tool_name": "kasa_tool",
  "tool_code": "\"\"\"\nTool for controlling TP-Link Kasa smart home devices.\n\nThis tool provides an interface to discover and control Kasa smart home devices\non the local network including plugs, bulbs, switches, light strips, and multi-outlet\npower strips.\n\nDatetime handling follows the UTC-everywhere approach:\n- All datetimes are stored in UTC internally\n- Timezone-aware datetime objects are used consistently\n- Conversion to local time happens only when displaying to users\n- The utility functions from utils.timezone_utils are used consistently\n\"\"\"\n\n# Standard library imports\nimport asyncio\nimport json\nimport logging\nimport os\nimport hashlib\nfrom typing import Dict, List, Any, Optional, Union, Set, Tuple\nfrom datetime import datetime, timedelta\n\n# Third-party imports\nimport aiohttp\nfrom pydantic import BaseModel, Field\n\n# Import timezone utilities for UTC-everywhere approach\nfrom utils.timezone_utils import utc_now, ensure_utc\n\n# Local imports\nfrom tools.repo import Tool\nfrom errors import ErrorCode, error_context, ToolError\nfrom config.registry import registry\n\n\n# -------------------- CONFIGURATION --------------------\n\nclass KasaToolConfig(BaseModel):\n    \"\"\"\n    Configuration for the kasa_tool.\n    \n    Defines the parameters that control the Kasa tool's behavior,\n    including device discovery, caching, and authentication.\n    \"\"\"\n    # Standard configuration parameter - all tools should include this\n    enabled: bool = Field(\n        default=True, \n        description=\"Whether this tool is enabled by default\"\n    )\n    \n    # Caching configuration\n    cache_enabled: bool = Field(\n        default=True, \n        description=\"Whether to cache device information\"\n    )\n    cache_duration: int = Field(\n        default=3600, \n        description=\"Cache duration in seconds (default: 1 hour)\"\n    )\n    cache_directory: str = Field(\n        default=\"data/tools/kasa_tool/cache\", \n        description=\"Directory to store cached device data\"\n    )\n    \n    # Discovery configuration\n    discovery_timeout: int = Field(\n        default=5, \n        description=\"Timeout in seconds for device discovery\"\n    )\n    discovery_target: str = Field(\n        default=\"255.255.255.255\", \n        description=\"Default target for device discovery\"\n    )\n    attempt_discovery_when_not_found: bool = Field(\n        default=True,\n        description=\"Whether to attempt discovery when a device is not found in cache\"\n    )\n    \n    # Authentication\n    default_username: str = Field(\n        default=\"\",\n        description=\"Default username for devices requiring authentication\"\n    )\n    default_password: str = Field(\n        default=\"\",\n        description=\"Default password for devices requiring authentication\"\n    )\n    \n    # Operation settings\n    verify_changes: bool = Field(\n        default=True,\n        description=\"Whether to verify changes after performing operations\"\n    )\n    verification_attempts: int = Field(\n        default=3,\n        description=\"Number of attempts to verify changes\"\n    )\n    verification_delay: float = Field(\n        default=0.5,\n        description=\"Delay in seconds between verification attempts\"\n    )\n\n# Register with registry\nregistry.register(\"kasa_tool\", KasaToolConfig)\n\n\n# -------------------- CACHE MANAGER --------------------\n\nclass DeviceCache:\n    \"\"\"\n    Manages caching of discovered devices to minimize network operations.\n    \"\"\"\n    \n    def __init__(self, cache_dir: str, cache_duration: int):\n        \"\"\"\n        Initialize the cache manager.\n        \n        Args:\n            cache_dir: Directory to store cache files\n            cache_duration: Cache validity duration in seconds\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_duration = cache_duration\n        \n        # Create cache directory if it doesn't exist\n        os.makedirs(cache_dir, exist_ok=True)\n    \n    def get_cache_path(self, key: str) -> str:\n        \"\"\"\n        Get the cache file path for a given key.\n        \n        Args:\n            key: Cache key\n            \n        Returns:\n            Path to the cache file\n        \"\"\"\n        # Create a hash of the key for the filename to avoid invalid characters\n        key_hash = hashlib.md5(key.encode()).hexdigest()\n        return os.path.join(self.cache_dir, f\"{key_hash}.json\")\n    \n    def is_valid(self, cache_path: str) -> bool:\n        \"\"\"\n        Check if a cache file is valid and not expired.\n        \n        Args:\n            cache_path: Path to the cache file\n            \n        Returns:\n            True if cache is valid, False otherwise\n        \"\"\"\n        # Check if file exists\n        if not os.path.exists(cache_path):\n            return False\n            \n        # Check if cache is expired based on file modification time\n        # Use utc_now timestamp for consistent timezone handling\n        cache_mtime = os.path.getmtime(cache_path)\n        cache_age = utc_now().timestamp() - cache_mtime\n        return cache_age < self.cache_duration\n    \n    def get(self, key: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get data from cache if available and valid.\n        \n        Args:\n            key: Cache key\n            \n        Returns:\n            Cached data or None if not available\n        \"\"\"\n        cache_path = self.get_cache_path(key)\n        \n        # Check if cache is valid\n        if not self.is_valid(cache_path):\n            return None\n            \n        # Read from cache\n        try:\n            with open(cache_path, 'r') as f:\n                return json.load(f)\n        except Exception as e:\n            logging.warning(f\"Failed to load cache for {key}: {str(e)}\")\n            return None\n    \n    def set(self, key: str, data: Dict[str, Any]) -> None:\n        \"\"\"\n        Save data to cache.\n        \n        Args:\n            key: Cache key\n            data: Data to cache\n        \"\"\"\n        cache_path = self.get_cache_path(key)\n        \n        try:\n            with open(cache_path, 'w') as f:\n                json.dump(data, f, indent=2)\n        except Exception as e:\n            logging.warning(f\"Failed to cache data for {key}: {str(e)}\")\n\n\n# -------------------- MAIN TOOL CLASS --------------------\n\nclass KasaTool(Tool):\n    \"\"\"\n    Tool for controlling TP-Link Kasa smart home devices.\n    \n    This tool provides functionality to discover and control Kasa smart home devices\n    on your local network including plugs, switches, bulbs, light strips, and multi-outlet\n    power strips.\n    \"\"\"\n    \n    name = \"kasa_tool\"\n    \n    description = \"\"\"\n    Controls TP-Link Kasa smart home devices on your local network. Use this tool to discover\n    and manage Kasa devices like smart plugs, light bulbs, switches, and light strips.\n    \n    OPERATIONS:\n    - discover_devices: Find all Kasa devices on your local network\n      Parameters:\n        target (optional): The network address to target for discovery (default: 255.255.255.255)\n        timeout (optional): Timeout in seconds for discovery (default: 5)\n        username (optional): Username for devices requiring authentication\n        password (optional): Password for devices requiring authentication\n        \n    - get_device_info: Get detailed information about a specific device\n      Parameters:\n        device_id (required): The device identifier (IP address, hostname, or alias)\n        \n    - power_control: Turn a device on or off\n      Parameters:\n        device_id (required): The device identifier\n        state (required): The desired state (\"on\" or \"off\")\n        \n    - set_brightness: Set the brightness of a light bulb or light strip\n      Parameters:\n        device_id (required): The device identifier\n        brightness (required): Brightness level (0-100)\n        \n    - set_color: Set the color of a light bulb or light strip\n      Parameters:\n        device_id (required): The device identifier\n        hue (required): Hue value (0-360)\n        saturation (required): Saturation value (0-100)\n        value (optional): Brightness value (0-100)\n        \n    - set_color_temp: Set the color temperature of a light bulb\n      Parameters:\n        device_id (required): The device identifier\n        temperature (required): Color temperature in Kelvin\n        \n    - get_energy_usage: Get energy usage data for supported devices\n      Parameters:\n        device_id (required): The device identifier\n        period (optional): Period to retrieve (\"realtime\", \"today\", \"month\")\n        \n    - set_device_alias: Set a new name for the device\n      Parameters:\n        device_id (required): The device identifier\n        alias (required): New name for the device\n        \n    - get_child_devices: Get information about child devices for power strips\n      Parameters:\n        device_id (required): The device identifier of the parent device\n        \n    - control_child_device: Control a specific outlet on a power strip\n      Parameters:\n        device_id (required): The device identifier of the parent device\n        child_id (required): The ID or index of the child device\n        state (required): The desired state (\"on\" or \"off\")\n    \n    RESPONSE FORMAT:\n    - All operations return a success flag and operation-specific data\n    \n    LIMITATIONS:\n    - Only works with devices on the same local network\n    - Some operations may require device-specific parameters\n    - Some devices may require authentication\n    \"\"\"\n    \n    usage_examples = [\n        {\n            \"input\": {\n                \"operation\": \"discover_devices\"\n            },\n            \"output\": {\n                \"success\": True,\n                \"devices\": [\n                    {\n                        \"id\": \"192.168.1.100\",\n                        \"alias\": \"Living Room Light\",\n                        \"model\": \"KL130\",\n                        \"type\": \"bulb\",\n                        \"state\": \"on\",\n                        \"features\": [\"brightness\", \"color\", \"temperature\"]\n                    },\n                    {\n                        \"id\": \"192.168.1.101\",\n                        \"alias\": \"Office Plug\",\n                        \"model\": \"HS110\",\n                        \"type\": \"plug\",\n                        \"state\": \"off\",\n                        \"features\": [\"energy\"]\n                    }\n                ],\n                \"message\": \"Found 2 Kasa devices on the network\"\n            }\n        },\n        {\n            \"input\": {\n                \"operation\": \"power_control\",\n                \"device_id\": \"Living Room Light\",\n                \"state\": \"off\"\n            },\n            \"output\": {\n                \"success\": True,\n                \"device\": {\n                    \"id\": \"192.168.1.100\",\n                    \"alias\": \"Living Room Light\",\n                    \"model\": \"KL130\",\n                    \"state\": \"off\"\n                },\n                \"message\": \"Turned Living Room Light off\"\n            }\n        },\n        {\n            \"input\": {\n                \"operation\": \"set_brightness\",\n                \"device_id\": \"Living Room Light\",\n                \"brightness\": 75\n            },\n            \"output\": {\n                \"success\": True,\n                \"device\": {\n                    \"id\": \"192.168.1.100\",\n                    \"alias\": \"Living Room Light\",\n                    \"state\": \"on\",\n                    \"brightness\": 75\n                },\n                \"message\": \"Set brightness of Living Room Light to 75%\"\n            }\n        }\n    ]\n    \n    def __init__(self):\n        \"\"\"Initialize the Kasa tool.\"\"\"\n        super().__init__()\n        self.logger = logging.getLogger(__name__)\n        self.logger.info(\"KasaTool initialized\")\n        \n        # Create required directories\n        from config import config\n        os.makedirs(config.kasa_tool.cache_directory, exist_ok=True)\n        \n        # Initialize device cache\n        self.cache = DeviceCache(\n            config.kasa_tool.cache_directory,\n            config.kasa_tool.cache_duration\n        )\n        \n        # In-memory device storage\n        self._device_instances = {}\n    \n    def run(self, operation: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Execute a Kasa tool operation.\n        \n        Args:\n            operation: The operation to perform\n            **kwargs: Operation-specific parameters\n            \n        Returns:\n            Dict containing the operation results\n            \n        Raises:\n            ToolError: If operation fails or parameters are invalid\n        \"\"\"\n        with error_context(\n            component_name=self.name,\n            operation=operation,\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger\n        ):\n            # Parse kwargs JSON string if provided that way\n            if \"kwargs\" in kwargs and isinstance(kwargs[\"kwargs\"], str):\n                try:\n                    params = json.loads(kwargs[\"kwargs\"])\n                    kwargs = params\n                except json.JSONDecodeError as e:\n                    raise ToolError(\n                        f\"Invalid JSON in kwargs: {e}\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n            \n            # Route to the appropriate operation\n            if operation == \"discover_devices\":\n                return asyncio.run(self._discover_devices(**kwargs))\n            elif operation == \"get_device_info\":\n                return asyncio.run(self._get_device_info(**kwargs))\n            elif operation == \"power_control\":\n                return asyncio.run(self._power_control(**kwargs))\n            elif operation == \"set_brightness\":\n                return asyncio.run(self._set_brightness(**kwargs))\n            elif operation == \"set_color\":\n                return asyncio.run(self._set_color(**kwargs))\n            elif operation == \"set_color_temp\":\n                return asyncio.run(self._set_color_temp(**kwargs))\n            elif operation == \"get_energy_usage\":\n                return asyncio.run(self._get_energy_usage(**kwargs))\n            elif operation == \"set_device_alias\":\n                return asyncio.run(self._set_device_alias(**kwargs))\n            elif operation == \"get_child_devices\":\n                return asyncio.run(self._get_child_devices(**kwargs))\n            elif operation == \"control_child_device\":\n                return asyncio.run(self._control_child_device(**kwargs))\n            else:\n                raise ToolError(\n                    f\"Unknown operation: {operation}. Valid operations are: \"\n                    \"discover_devices, get_device_info, power_control, set_brightness, \"\n                    \"set_color, set_color_temp, get_energy_usage, set_device_alias, \"\n                    \"get_child_devices, control_child_device\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n    \n    async def _discover_devices(\n        self,\n        target: Optional[str] = None,\n        timeout: Optional[int] = None,\n        username: Optional[str] = None,\n        password: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Discover Kasa devices on the local network.\n        \n        Args:\n            target: The network address to target for discovery\n            timeout: Timeout in seconds for discovery\n            username: Username for devices requiring authentication\n            password: Password for devices requiring authentication\n            \n        Returns:\n            Dict containing information about discovered devices\n        \"\"\"\n        from kasa import Discover, Credentials\n        from config import config\n        \n        # Use default values from config if not provided\n        target = target or config.kasa_tool.discovery_target\n        timeout = timeout or config.kasa_tool.discovery_timeout\n        \n        # Process credentials\n        credentials = None\n        if username and password:\n            credentials = Credentials(username, password)\n        elif config.kasa_tool.default_username and config.kasa_tool.default_password:\n            credentials = Credentials(\n                config.kasa_tool.default_username,\n                config.kasa_tool.default_password\n            )\n        \n        self.logger.info(f\"Discovering Kasa devices on {target} with timeout {timeout}s\")\n        \n        try:\n            # Perform device discovery\n            found_devices = await Discover.discover(\n                target=target,\n                discovery_timeout=timeout,\n                credentials=credentials\n            )\n            \n            # Update devices after discovery to get full information\n            device_details = []\n            for device in found_devices.values():\n                try:\n                    await device.update()\n                    self._cache_device(device)\n                    device_details.append(self._serialize_device_summary(device))\n                except Exception as e:\n                    self.logger.warning(f\"Error updating device {device.host}: {e}\")\n            \n            return {\n                \"success\": True,\n                \"devices\": device_details,\n                \"message\": f\"Found {len(device_details)} Kasa device(s) on the network\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error discovering devices: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _get_device_info(self, device_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific device.\n        \n        Args:\n            device_id: The device identifier (IP address, hostname, or alias)\n            \n        Returns:\n            Dict containing device information\n        \"\"\"\n        self.logger.info(f\"Getting info for device: {device_id}\")\n        \n        try:\n            # Get device and ensure it's updated\n            device = await self._get_device_by_id(device_id)\n            await device.update()\n            \n            # Cache the device after update\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"device\": self._serialize_device_details(device),\n                \"message\": f\"Retrieved information for {device.alias or device.host}\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error getting device info: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _power_control(self, device_id: str, state: str) -> Dict[str, Any]:\n        \"\"\"\n        Turn a device on or off.\n        \n        Args:\n            device_id: The device identifier\n            state: The desired state (\"on\" or \"off\")\n            \n        Returns:\n            Dict containing the operation result\n        \"\"\"\n        self.logger.info(f\"Setting power state for {device_id} to {state}\")\n        \n        # Validate state\n        if state.lower() not in [\"on\", \"off\"]:\n            raise ToolError(\n                f\"Invalid state: {state}. Must be 'on' or 'off'\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Set the state\n            if state.lower() == \"on\":\n                await device.turn_on()\n            else:\n                await device.turn_off()\n            \n            # Verify the change\n            from config import config\n            if config.kasa_tool.verify_changes:\n                await self._verify_change(\n                    device, \n                    state.lower() == \"on\", \n                    \"is_on\",\n                    config.kasa_tool.verification_attempts,\n                    config.kasa_tool.verification_delay\n                )\n            \n            # Update the device to get current state\n            await device.update()\n            \n            # Cache the updated device\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"device\": self._serialize_device_summary(device),\n                \"message\": f\"Turned {device.alias or device.host} {state.lower()}\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error controlling device: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _set_brightness(self, device_id: str, brightness: Union[int, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set the brightness of a light bulb or light strip.\n        \n        Args:\n            device_id: The device identifier\n            brightness: Brightness level (0-100)\n            \n        Returns:\n            Dict containing the operation result\n        \"\"\"\n        self.logger.info(f\"Setting brightness for {device_id} to {brightness}\")\n        \n        # Validate and convert brightness\n        try:\n            brightness_value = int(brightness)\n            if brightness_value < 0 or brightness_value > 100:\n                raise ValueError(\"Brightness must be between 0 and 100\")\n        except (ValueError, TypeError) as e:\n            raise ToolError(\n                f\"Invalid brightness value: {brightness}. Must be an integer between 0 and 100\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Check if device supports brightness\n            light_module = None\n            if \"Light\" in device.modules:\n                light_module = device.modules[\"Light\"]\n            \n            if not light_module or not hasattr(light_module, 'set_brightness'):\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not support brightness control\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Set brightness\n            await light_module.set_brightness(brightness_value)\n            \n            # Verify the change\n            from config import config\n            if config.kasa_tool.verify_changes:\n                await self._verify_change(\n                    light_module, \n                    brightness_value, \n                    \"brightness\",\n                    config.kasa_tool.verification_attempts,\n                    config.kasa_tool.verification_delay\n                )\n            \n            # Update the device to get current state\n            await device.update()\n            \n            # Cache the updated device\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"device\": self._serialize_device_summary(device),\n                \"message\": f\"Set brightness of {device.alias or device.host} to {brightness_value}%\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error setting brightness: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _set_color(\n        self, \n        device_id: str, \n        hue: Union[int, str], \n        saturation: Union[int, str], \n        value: Optional[Union[int, str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Set the color of a light bulb or light strip.\n        \n        Args:\n            device_id: The device identifier\n            hue: Hue value (0-360)\n            saturation: Saturation value (0-100)\n            value: Brightness value (0-100)\n            \n        Returns:\n            Dict containing the operation result\n        \"\"\"\n        self.logger.info(f\"Setting color for {device_id} to H:{hue} S:{saturation} V:{value}\")\n        \n        # Validate and convert color values\n        try:\n            hue_value = int(hue)\n            if hue_value < 0 or hue_value > 360:\n                raise ValueError(\"Hue must be between 0 and 360\")\n                \n            saturation_value = int(saturation)\n            if saturation_value < 0 or saturation_value > 100:\n                raise ValueError(\"Saturation must be between 0 and 100\")\n                \n            if value is not None:\n                value_value = int(value)\n                if value_value < 0 or value_value > 100:\n                    raise ValueError(\"Value must be between 0 and 100\")\n            else:\n                value_value = None\n        except (ValueError, TypeError) as e:\n            raise ToolError(\n                f\"Invalid color values: {str(e)}\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Check if device supports color\n            light_module = None\n            if \"Light\" in device.modules:\n                light_module = device.modules[\"Light\"]\n            \n            if not light_module or not hasattr(light_module, 'set_hsv'):\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not support color control\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Set HSV\n            if value_value is not None:\n                await light_module.set_hsv(hue_value, saturation_value, value_value)\n            else:\n                # Use current brightness if value not provided\n                current_hsv = getattr(light_module, 'hsv', None)\n                current_value = current_hsv.value if current_hsv else 100\n                await light_module.set_hsv(hue_value, saturation_value, current_value)\n            \n            # Update the device to get current state\n            await device.update()\n            \n            # Cache the updated device\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"device\": self._serialize_device_summary(device),\n                \"message\": f\"Set color of {device.alias or device.host} to HSV({hue_value}, {saturation_value}, {value_value or current_value})\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error setting color: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _set_color_temp(self, device_id: str, temperature: Union[int, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set the color temperature of a light bulb.\n        \n        Args:\n            device_id: The device identifier\n            temperature: Color temperature in Kelvin\n            \n        Returns:\n            Dict containing the operation result\n        \"\"\"\n        self.logger.info(f\"Setting color temperature for {device_id} to {temperature}K\")\n        \n        # Validate and convert temperature\n        try:\n            temperature_value = int(temperature)\n            if temperature_value < 2500 or temperature_value > 9000:\n                raise ValueError(\"Temperature must be between 2500K and 9000K\")\n        except (ValueError, TypeError) as e:\n            raise ToolError(\n                f\"Invalid temperature value: {temperature}. Must be an integer between 2500 and 9000\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Check if device supports color temperature\n            light_module = None\n            if \"Light\" in device.modules:\n                light_module = device.modules[\"Light\"]\n            \n            if not light_module or not hasattr(light_module, 'set_color_temp'):\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not support color temperature control\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Set color temperature\n            await light_module.set_color_temp(temperature_value)\n            \n            # Verify the change\n            from config import config\n            if config.kasa_tool.verify_changes:\n                await self._verify_change(\n                    light_module, \n                    temperature_value, \n                    \"color_temp\",\n                    config.kasa_tool.verification_attempts,\n                    config.kasa_tool.verification_delay\n                )\n            \n            # Update the device to get current state\n            await device.update()\n            \n            # Cache the updated device\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"device\": self._serialize_device_summary(device),\n                \"message\": f\"Set color temperature of {device.alias or device.host} to {temperature_value}K\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error setting color temperature: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _get_energy_usage(self, device_id: str, period: str = \"realtime\") -> Dict[str, Any]:\n        \"\"\"\n        Get energy usage data for supported devices.\n        \n        Args:\n            device_id: The device identifier\n            period: Period to retrieve (\"realtime\", \"today\", \"month\")\n            \n        Returns:\n            Dict containing energy usage data\n        \"\"\"\n        self.logger.info(f\"Getting energy usage for {device_id} for period: {period}\")\n        \n        # Validate period\n        valid_periods = [\"realtime\", \"today\", \"month\"]\n        if period.lower() not in valid_periods:\n            raise ToolError(\n                f\"Invalid period: {period}. Must be one of: {', '.join(valid_periods)}\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Check if device supports energy monitoring\n            if not device.has_emeter:\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not support energy monitoring\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Get the energy module\n            energy_module = None\n            if \"Energy\" in device.modules:\n                energy_module = device.modules[\"Energy\"]\n            else:\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not have energy module\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Get energy data based on period\n            energy_data = {}\n            if period.lower() == \"realtime\":\n                await energy_module.update()  # Ensure we have the latest data\n                energy_data = {\n                    \"current_power\": energy_module.current_consumption,\n                    \"voltage\": getattr(energy_module, 'voltage', None),\n                    \"current\": getattr(energy_module, 'current', None)\n                }\n                message = f\"Current power usage for {device.alias or device.host} is {energy_data['current_power']}W\"\n            elif period.lower() == \"today\":\n                energy_data = {\n                    \"consumption_today\": energy_module.consumption_today\n                }\n                message = f\"Energy consumption today for {device.alias or device.host} is {energy_data['consumption_today']}kWh\"\n            elif period.lower() == \"month\":\n                energy_data = {\n                    \"consumption_month\": energy_module.consumption_this_month\n                }\n                message = f\"Energy consumption this month for {device.alias or device.host} is {energy_data['consumption_month']}kWh\"\n            \n            return {\n                \"success\": True,\n                \"device\": {\n                    \"id\": device.host,\n                    \"alias\": device.alias,\n                    \"model\": device.model\n                },\n                \"energy_data\": energy_data,\n                \"message\": message\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error getting energy usage: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _set_device_alias(self, device_id: str, alias: str) -> Dict[str, Any]:\n        \"\"\"\n        Set a new name for the device.\n        \n        Args:\n            device_id: The device identifier\n            alias: New name for the device\n            \n        Returns:\n            Dict containing the operation result\n        \"\"\"\n        self.logger.info(f\"Setting alias for {device_id} to {alias}\")\n        \n        # Validate alias\n        if not alias or not isinstance(alias, str):\n            raise ToolError(\n                \"Alias must be a non-empty string\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Save old alias for the response message\n            old_alias = device.alias or device.host\n            \n            # Set new alias\n            await device.set_alias(alias)\n            \n            # Update the device to get current state\n            await device.update()\n            \n            # Cache the updated device\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"device\": self._serialize_device_summary(device),\n                \"message\": f\"Renamed device from '{old_alias}' to '{device.alias}'\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error setting device alias: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _get_child_devices(self, device_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get information about child devices for power strips.\n        \n        Args:\n            device_id: The device identifier of the parent device\n            \n        Returns:\n            Dict containing information about child devices\n        \"\"\"\n        self.logger.info(f\"Getting child devices for {device_id}\")\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Check if device has children\n            if not hasattr(device, 'children') or not device.children:\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not have child devices\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Get information about child devices\n            child_devices = []\n            for child in device.children:\n                child_devices.append(self._serialize_device_summary(child))\n            \n            return {\n                \"success\": True,\n                \"parent_device\": {\n                    \"id\": device.host,\n                    \"alias\": device.alias,\n                    \"model\": device.model\n                },\n                \"child_devices\": child_devices,\n                \"message\": f\"Found {len(child_devices)} child devices for {device.alias or device.host}\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error getting child devices: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    async def _control_child_device(\n        self, \n        device_id: str, \n        child_id: str, \n        state: str\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Control a specific outlet on a power strip.\n        \n        Args:\n            device_id: The device identifier of the parent device\n            child_id: The ID or index of the child device\n            state: The desired state (\"on\" or \"off\")\n            \n        Returns:\n            Dict containing the operation result\n        \"\"\"\n        self.logger.info(f\"Controlling child device {child_id} of {device_id} with state {state}\")\n        \n        # Validate state\n        if state.lower() not in [\"on\", \"off\"]:\n            raise ToolError(\n                f\"Invalid state: {state}. Must be 'on' or 'off'\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n        \n        try:\n            device = await self._get_device_by_id(device_id)\n            \n            # Check if device has children\n            if not hasattr(device, 'children') or not device.children:\n                raise ToolError(\n                    f\"Device {device.alias or device.host} does not have child devices\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n            \n            # Get child device by ID or index\n            child_device = None\n            \n            # First try to get by alias\n            child_device = device.get_plug_by_name(child_id)\n            \n            # If not found by alias, try by index\n            if not child_device and child_id.isdigit():\n                try:\n                    index = int(child_id)\n                    child_device = device.get_plug_by_index(index)\n                except Exception:\n                    pass\n            \n            if not child_device:\n                raise ToolError(\n                    f\"Child device {child_id} not found\",\n                    ErrorCode.TOOL_NOT_FOUND\n                )\n            \n            # Set the state\n            if state.lower() == \"on\":\n                await child_device.turn_on()\n            else:\n                await child_device.turn_off()\n            \n            # Verify the change\n            from config import config\n            if config.kasa_tool.verify_changes:\n                await self._verify_change(\n                    child_device, \n                    state.lower() == \"on\", \n                    \"is_on\",\n                    config.kasa_tool.verification_attempts,\n                    config.kasa_tool.verification_delay\n                )\n            \n            # Update the device to get current state\n            await device.update()\n            \n            # Cache the updated device\n            self._cache_device(device)\n            \n            return {\n                \"success\": True,\n                \"parent_device\": {\n                    \"id\": device.host,\n                    \"alias\": device.alias,\n                    \"model\": device.model\n                },\n                \"child_device\": self._serialize_device_summary(child_device),\n                \"message\": f\"Turned {child_device.alias or child_id} {state.lower()}\"\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Error controlling child device: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n    \n    # -------------------- HELPER METHODS --------------------\n    \n    async def _get_device_by_id(\n        self, \n        device_id: str, \n        force_discovery: bool = False\n    ) -> Any:\n        \"\"\"\n        Get a device by its identifier, using cache when available.\n        \n        Args:\n            device_id: The device identifier (IP address, hostname, or alias)\n            force_discovery: Whether to force device discovery\n            \n        Returns:\n            Device object\n            \n        Raises:\n            ToolError: If device cannot be found\n        \"\"\"\n        from kasa import Device, Credentials, Discover\n        from config import config\n        \n        # Check for cached instance first\n        if device_id in self._device_instances and not force_discovery:\n            device = self._device_instances[device_id]\n            try:\n                await device.update()\n                return device\n            except Exception as e:\n                self.logger.warning(f\"Error updating cached device {device_id}: {e}\")\n                # Continue to try other methods if update fails\n        \n        # Try to parse as IP address or hostname\n        try:\n            # Try to get credentials\n            credentials = None\n            if config.kasa_tool.default_username and config.kasa_tool.default_password:\n                credentials = Credentials(\n                    config.kasa_tool.default_username,\n                    config.kasa_tool.default_password\n                )\n            \n            # Try to connect directly\n            device = await Discover.discover_single(\n                device_id,\n                credentials=credentials\n            )\n            \n            if device:\n                self._device_instances[device_id] = device\n                self._device_instances[device.host] = device\n                if device.alias:\n                    self._device_instances[device.alias] = device\n                return device\n        except Exception as e:\n            self.logger.warning(f\"Error connecting directly to {device_id}: {e}\")\n            # Continue to try other methods if connection fails\n        \n        # Check for cached devices by alias\n        # Loop through all devices and try to match by alias\n        devices_to_check = []\n        \n        # Get from cache if available and enabled\n        if config.kasa_tool.cache_enabled and not force_discovery:\n            # Get all cached devices\n            cache_dir = config.kasa_tool.cache_directory\n            if os.path.exists(cache_dir):\n                for cache_file in os.listdir(cache_dir):\n                    if cache_file.endswith('.json'):\n                        cache_path = os.path.join(cache_dir, cache_file)\n                        try:\n                            with open(cache_path, 'r') as f:\n                                device_data = json.load(f)\n                                if device_data.get('host') or device_data.get('alias'):\n                                    devices_to_check.append(device_data)\n                        except Exception as e:\n                            self.logger.warning(f\"Error reading cache file {cache_file}: {e}\")\n        \n        # Check if any cached device matches by alias\n        for device_data in devices_to_check:\n            if (device_data.get('alias') == device_id or \n                device_data.get('host') == device_id):\n                try:\n                    # Try to connect to the device\n                    device = await Device.connect(\n                        host=device_data.get('host'),\n                        config=None\n                    )\n                    \n                    if device:\n                        self._device_instances[device_id] = device\n                        self._device_instances[device.host] = device\n                        if device.alias:\n                            self._device_instances[device.alias] = device\n                        return device\n                except Exception as e:\n                    self.logger.warning(f\"Error connecting to cached device {device_data.get('host')}: {e}\")\n                    # Continue to next cached device\n        \n        # If still not found and discovery is allowed\n        if config.kasa_tool.attempt_discovery_when_not_found or force_discovery:\n            try:\n                # Perform device discovery\n                found_devices = await Discover.discover(\n                    target=config.kasa_tool.discovery_target,\n                    discovery_timeout=config.kasa_tool.discovery_timeout,\n                    credentials=credentials\n                )\n                \n                # Check if any discovered device matches by alias\n                for host, device in found_devices.items():\n                    try:\n                        await device.update()\n                        \n                        # Cache all discovered devices\n                        self._cache_device(device)\n                        \n                        # Add to in-memory cache\n                        self._device_instances[host] = device\n                        if device.alias:\n                            self._device_instances[device.alias] = device\n                            \n                        # Check if this device matches the requested ID\n                        if device.alias == device_id or host == device_id:\n                            return device\n                    except Exception as e:\n                        self.logger.warning(f\"Error updating discovered device {host}: {e}\")\n                        # Continue to next discovered device\n            except Exception as e:\n                self.logger.warning(f\"Error during device discovery: {e}\")\n                # Continue to final error\n        \n        # If we get here, device was not found\n        raise ToolError(\n            f\"Device '{device_id}' not found. Make sure it is connected to your network and try again.\",\n            ErrorCode.TOOL_NOT_FOUND\n        )\n    \n    def _serialize_device_summary(self, device: Any) -> Dict[str, Any]:\n        \"\"\"\n        Serialize basic device information for response.\n        \n        Args:\n            device: The device object\n            \n        Returns:\n            Dict containing basic device information\n        \"\"\"\n        # Basic device information\n        result = {\n            \"id\": device.host,\n            \"alias\": device.alias,\n            \"model\": device.model,\n            \"state\": \"on\" if device.is_on else \"off\"\n        }\n        \n        # Add device type\n        device_type = str(device.device_type).lower()\n        if 'bulb' in device_type:\n            result[\"type\"] = \"bulb\"\n        elif 'plug' in device_type:\n            result[\"type\"] = \"plug\"\n        elif 'strip' in device_type:\n            result[\"type\"] = \"strip\"\n        elif 'dimmer' in device_type or 'switch' in device_type:\n            result[\"type\"] = \"switch\"\n        elif 'lightstrip' in device_type:\n            result[\"type\"] = \"lightstrip\"\n        else:\n            result[\"type\"] = \"other\"\n        \n        # Add supported features\n        features = []\n        \n        # Check for brightness support\n        if \"Light\" in device.modules and hasattr(device.modules[\"Light\"], \"brightness\"):\n            features.append(\"brightness\")\n            result[\"brightness\"] = device.modules[\"Light\"].brightness\n        \n        # Check for color support\n        if \"Light\" in device.modules and hasattr(device.modules[\"Light\"], \"hsv\"):\n            features.append(\"color\")\n            hsv = device.modules[\"Light\"].hsv\n            if hsv:\n                result[\"color\"] = {\n                    \"hue\": hsv.hue,\n                    \"saturation\": hsv.saturation,\n                    \"value\": hsv.value\n                }\n        \n        # Check for color temperature support\n        if \"Light\" in device.modules and hasattr(device.modules[\"Light\"], \"color_temp\"):\n            features.append(\"temperature\")\n            result[\"color_temp\"] = device.modules[\"Light\"].color_temp\n        \n        # Check for energy monitoring support\n        if device.has_emeter:\n            features.append(\"energy\")\n            if \"Energy\" in device.modules:\n                result[\"power\"] = device.modules[\"Energy\"].current_consumption\n        \n        # Add features list to result\n        result[\"features\"] = features\n        \n        return result\n    \n    def _serialize_device_details(self, device: Any) -> Dict[str, Any]:\n        \"\"\"\n        Serialize detailed device information for response.\n        \n        Args:\n            device: The device object\n            \n        Returns:\n            Dict containing detailed device information\n        \"\"\"\n        # Start with summary\n        result = self._serialize_device_summary(device)\n        \n        # Add additional information\n        result[\"mac\"] = device.mac\n        result[\"rssi\"] = device.rssi\n        result[\"hardware_version\"] = device.device_info.hardware_version\n        result[\"firmware_version\"] = device.device_info.firmware_version\n        \n        # Add time information\n        if hasattr(device, \"time\"):\n            result[\"device_time\"] = device.time.isoformat()\n        if device.on_since:\n            result[\"on_since\"] = device.on_since.isoformat()\n        \n        # Add modules list\n        result[\"modules\"] = list(device.modules.keys())\n        \n        # Add features detailed information\n        result[\"features_details\"] = {}\n        for feature_id, feature in device.features.items():\n            result[\"features_details\"][feature_id] = {\n                \"name\": feature.name,\n                \"value\": str(feature.value)\n            }\n        \n        # Add energy information if supported\n        if device.has_emeter and \"Energy\" in device.modules:\n            energy_module = device.modules[\"Energy\"]\n            result[\"energy\"] = {\n                \"current_consumption\": energy_module.current_consumption,\n                \"consumption_today\": energy_module.consumption_today,\n                \"consumption_month\": energy_module.consumption_this_month,\n                \"voltage\": getattr(energy_module, \"voltage\", None),\n                \"current\": getattr(energy_module, \"current\", None)\n            }\n        \n        # Add child devices if any\n        if hasattr(device, \"children\") and device.children:\n            result[\"child_devices\"] = []\n            for child in device.children:\n                result[\"child_devices\"].append(self._serialize_device_summary(child))\n        \n        return result\n    \n    def _cache_device(self, device: Any) -> None:\n        \"\"\"\n        Cache a device for future use.\n        \n        Args:\n            device: The device object to cache\n        \"\"\"\n        from config import config\n        \n        if not config.kasa_tool.cache_enabled:\n            return\n        \n        try:\n            # Generate cache key from device host\n            cache_key = device.host\n            \n            # Prepare device data for caching\n            device_data = {\n                \"host\": device.host,\n                \"alias\": device.alias,\n                \"model\": device.model,\n                \"mac\": device.mac,\n                \"device_type\": str(device.device_type),\n                \"last_updated\": utc_now().isoformat()\n            }\n            \n            # Add to cache\n            self.cache.set(cache_key, device_data)\n            \n            # Also cache by alias if available\n            if device.alias:\n                self.cache.set(device.alias, device_data)\n                \n            # Store in memory cache\n            self._device_instances[device.host] = device\n            if device.alias:\n                self._device_instances[device.alias] = device\n                \n        except Exception as e:\n            self.logger.warning(f\"Error caching device {device.host}: {e}\")\n    \n    async def _verify_change(\n        self, \n        device: Any, \n        expected_value: Any, \n        attribute: str,\n        max_attempts: int = 3,\n        delay: float = 0.5\n    ) -> bool:\n        \"\"\"\n        Verify a change was successful by checking the device state.\n        \n        Args:\n            device: The device or module object\n            expected_value: The expected value\n            attribute: The attribute to check\n            max_attempts: Maximum number of verification attempts\n            delay: Delay between verification attempts in seconds\n            \n        Returns:\n            True if the change was successful, False otherwise\n        \"\"\"\n        for attempt in range(max_attempts):\n            try:\n                # If device has an update method, use it\n                if hasattr(device, \"update\"):\n                    await device.update()\n                # If device has a parent with an update method, use that\n                elif hasattr(device, \"_device\") and hasattr(device._device, \"update\"):\n                    await device._device.update()\n                    \n                # Check if the attribute has the expected value\n                current_value = getattr(device, attribute, None)\n                if current_value == expected_value:\n                    return True\n                    \n                # If not, wait and retry\n                await asyncio.sleep(delay)\n            except Exception as e:\n                self.logger.warning(f\"Error verifying change: {e}\")\n                await asyncio.sleep(delay)\n                \n        # If we get here, verification failed\n        self.logger.warning(\n            f\"Failed to verify change: expected {attribute}={expected_value}, \"\n            f\"got {getattr(device, attribute, None)}\"\n        )\n        return False",
  "description": "A tool for discovering and controlling TP-Link Kasa smart home devices on the local network, including plugs, bulbs, switches, light strips, and multi-outlet power strips.",
  "operations": [
    {
      "name": "discover_devices",
      "description": "Finds all Kasa devices on the local network and returns their basic information.",
      "required_parameters": [],
      "optional_parameters": [
        {
          "name": "target",
          "type": "string",
          "description": "The network address to target for discovery",
          "default": "255.255.255.255"
        },
        {
          "name": "timeout",
          "type": "integer",
          "description": "Timeout in seconds for discovery",
          "default": 5
        },
        {
          "name": "username",
          "type": "string",
          "description": "Username for devices requiring authentication",
          "default": null
        },
        {
          "name": "password",
          "type": "string",
          "description": "Password for devices requiring authentication",
          "default": null
        }
      ]
    },
    {
      "name": "get_device_info",
      "description": "Retrieves detailed information about a specific Kasa device.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "power_control",
      "description": "Turns a Kasa device on or off.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        },
        {
          "name": "state",
          "type": "string",
          "description": "The desired power state ('on' or 'off')"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "set_brightness",
      "description": "Sets the brightness level of a light bulb or light strip.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        },
        {
          "name": "brightness",
          "type": "integer",
          "description": "Brightness level (0-100)"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "set_color",
      "description": "Sets the color of a light bulb or light strip using HSV values.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        },
        {
          "name": "hue",
          "type": "integer",
          "description": "Hue value (0-360)"
        },
        {
          "name": "saturation",
          "type": "integer",
          "description": "Saturation value (0-100)"
        }
      ],
      "optional_parameters": [
        {
          "name": "value",
          "type": "integer",
          "description": "Brightness value (0-100)",
          "default": "current brightness"
        }
      ]
    },
    {
      "name": "set_color_temp",
      "description": "Sets the color temperature of a light bulb.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        },
        {
          "name": "temperature",
          "type": "integer",
          "description": "Color temperature in Kelvin (2500-9000)"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "get_energy_usage",
      "description": "Retrieves energy usage data for supported devices.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        }
      ],
      "optional_parameters": [
        {
          "name": "period",
          "type": "string",
          "description": "Period to retrieve ('realtime', 'today', 'month')",
          "default": "realtime"
        }
      ]
    },
    {
      "name": "set_device_alias",
      "description": "Sets a new name (alias) for a device.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier (IP address, hostname, or alias)"
        },
        {
          "name": "alias",
          "type": "string",
          "description": "New name for the device"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "get_child_devices",
      "description": "Retrieves information about child devices for power strips or multi-outlet devices.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier of the parent device"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "control_child_device",
      "description": "Controls a specific outlet on a power strip or multi-outlet device.",
      "required_parameters": [
        {
          "name": "device_id",
          "type": "string",
          "description": "The device identifier of the parent device"
        },
        {
          "name": "child_id",
          "type": "string",
          "description": "The ID or index of the child device"
        },
        {
          "name": "state",
          "type": "string",
          "description": "The desired state ('on' or 'off')"
        }
      ],
      "optional_parameters": []
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}