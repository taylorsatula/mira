{
  "tool_name": "reminder_tool",
  "tool_code": "\"\"\"\nReminder tool for managing scheduled reminders.\n\nThis tool allows users to create reminders with specific dates, details,\nand contact information. It stores reminders in a SQLite database and provides\nfunctions to add, retrieve, and manage reminders.\n\"\"\"\n\nimport logging\nimport os\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\nfrom dateutil import parser as date_parser\nfrom sqlalchemy import Column, String, DateTime, Text, Boolean\nfrom dateutil.relativedelta import relativedelta\n\nfrom tools.repo import Tool\nfrom errors import ToolError, ErrorCode, error_context\nfrom db import Database, Base\n\n\nclass Reminder(Base):\n    \"\"\"\n    Reminder model for storing reminder data.\n    \n    Maps to the 'reminders' table with columns for reminder details\n    including contact information and scheduling.\n    \"\"\"\n    __tablename__ = 'reminders'\n\n    # Primary key\n    id = Column(String, primary_key=True)\n    \n    # Reminder details\n    title = Column(String, nullable=False)\n    description = Column(Text)\n    \n    # Scheduling information\n    reminder_date = Column(DateTime, nullable=False)\n    created_at = Column(DateTime, default=lambda: datetime.now())\n    completed = Column(Boolean, default=False)\n    completed_at = Column(DateTime)\n    \n    # Contact information\n    contact_name = Column(String)\n    contact_email = Column(String)\n    contact_phone = Column(String)\n    customer_id = Column(String)  # Reference to customer in customer database if available\n    \n    # Additional data (optional)\n    additional_notes = Column(Text)\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert the model to a dictionary.\n        \n        Returns:\n            Dict representation of the reminder\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"reminder_date\": self.reminder_date.isoformat() if self.reminder_date else None,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed\": self.completed,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"contact_name\": self.contact_name,\n            \"contact_email\": self.contact_email,\n            \"contact_phone\": self.contact_phone,\n            \"customer_id\": self.customer_id,\n            \"additional_notes\": self.additional_notes\n        }\n\n\nclass ReminderTool(Tool):\n    \"\"\"\n    Tool for managing reminders with customer contact integration.\n    \n    This tool allows setting and retrieving reminders for specific dates with\n    detailed contact information. It integrates with the customer database\n    to fetch complete contact details when available.\n    \"\"\"\n\n    name = \"reminder_tool\"\n    description = \"\"\"\n    Manages scheduled reminders with contact information integration. Use this tool when the user\n    wants to create, view, or manage reminders about tasks, follow-ups, or appointments.\n    \n    The tool supports these operations:\n    \n    1. add_reminder: Create a new reminder with a date, description, and optional contact info.\n       - Required: title (brief description), date (when to be reminded)\n       - Optional: description (details), contact_name, contact_email, contact_phone\n       - If a contact name is provided, attempts to find matching customer information\n       - Returns the created reminder with a unique identifier\n    \n    2. get_reminders: Retrieve reminders for a specific date range.\n       - Required: date_type (\"today\", \"tomorrow\", \"upcoming\", \"past\", \"all\", \"date\" or \"range\")\n       - If date_type is \"date\", requires specific_date parameter\n       - If date_type is \"range\", requires start_date and end_date parameters\n       - Returns list of reminders matching the criteria\n    \n    3. mark_completed: Mark a reminder as completed.\n       - Required: reminder_id (the ID of the reminder to mark as completed)\n       - Returns the updated reminder\n       \n    4. update_reminder: Update an existing reminder's details.\n       - Required: reminder_id (the ID of the reminder to update)\n       - Optional: Any fields to update (title, description, date, contact information)\n       - Returns the updated reminder\n       \n    5. delete_reminder: Remove a reminder.\n       - Required: reminder_id (the ID of the reminder to delete)\n       - Returns confirmation of deletion\n       \n    This tool automatically integrates with the customer database when contact names are provided,\n    fetching complete contact information for known customers. When creating reminders with a name\n    that doesn't match an existing customer, the tool will prompt for additional contact details.\n    \"\"\"\n    \n    usage_examples = [\n        {\n            \"input\": {\n                \"operation\": \"add_reminder\",\n                \"title\": \"Window cleaning follow-up\",\n                \"date\": \"in 3 weeks\",\n                \"description\": \"Call to schedule window cleaning service\",\n                \"contact_name\": \"John Smith\"\n            },\n            \"output\": {\n                \"reminder\": {\n                    \"id\": \"rem_123456\",\n                    \"title\": \"Window cleaning follow-up\",\n                    \"description\": \"Call to schedule window cleaning service\",\n                    \"reminder_date\": \"2025-05-13T12:00:00\",\n                    \"contact_name\": \"John Smith\",\n                    \"contact_email\": \"john.smith@example.com\",\n                    \"contact_phone\": \"256-555-1234\"\n                }\n            }\n        },\n        {\n            \"input\": {\n                \"operation\": \"get_reminders\",\n                \"date_type\": \"upcoming\"\n            },\n            \"output\": {\n                \"reminders\": [\n                    {\n                        \"id\": \"rem_123456\",\n                        \"title\": \"Window cleaning follow-up\",\n                        \"description\": \"Call to schedule window cleaning service\",\n                        \"reminder_date\": \"2025-05-13T12:00:00\",\n                        \"contact_name\": \"John Smith\"\n                    }\n                ]\n            }\n        }\n    ]\n\n    def __init__(self):\n        \"\"\"Initialize the reminder tool with database access.\"\"\"\n        super().__init__()\n        self.db = Database()\n        \n        # Ensure data directory exists\n        self.data_dir = os.path.join(\"data\", \"tools\", \"reminder_tool\")\n        os.makedirs(self.data_dir, exist_ok=True)\n        \n        # Initialize logger\n        self.logger = logging.getLogger(__name__)\n        self.logger.info(\"ReminderTool initialized\")\n\n    def run(self, operation: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Execute a reminder operation.\n\n        Args:\n            operation: Operation to perform (see below for valid operations)\n            **kwargs: Parameters for the specific operation\n\n        Returns:\n            Response data for the operation\n\n        Raises:\n            ToolError: If operation fails or parameters are invalid\n\n        Valid Operations:\n\n        1. add_reminder: Create a new reminder\n           - Required: title, date\n           - Optional: description, contact_name, contact_email, contact_phone, additional_notes\n           - Returns: Dict with created reminder\n\n        2. get_reminders: Retrieve reminders\n           - Required: date_type (\"today\", \"tomorrow\", \"upcoming\", \"past\", \"all\", \"date\" or\n            \"range\")\n           - If date_type is \"date\", requires specific_date parameter\n           - If date_type is \"range\", requires start_date and end_date parameters\n           - Returns: Dict with list of reminders\n\n        3. mark_completed: Mark a reminder as completed\n           - Required: reminder_id\n           - Returns: Dict with updated reminder\n\n        4. update_reminder: Update an existing reminder\n           - Required: reminder_id\n           - Optional: Any fields to update (title, description, date, contact information)\n           - Returns: Dict with updated reminder\n\n        5. delete_reminder: Delete a reminder\n           - Required: reminder_id\n           - Returns: Dict with deletion confirmation\n        \"\"\"\n        with error_context(\n            component_name=self.name,\n            operation=f\"executing {operation}\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger,\n        ):\n            # Parse kwargs JSON string if provided that way\n            if \"kwargs\" in kwargs and isinstance(kwargs[\"kwargs\"], str):\n                try:\n                    params = json.loads(kwargs[\"kwargs\"])\n                    kwargs = params\n                except json.JSONDecodeError as e:\n                    raise ToolError(\n                        f\"Invalid JSON in kwargs: {e}\", ErrorCode.TOOL_INVALID_INPUT\n                    )\n            \n            # Route to the appropriate operation\n            if operation == \"add_reminder\":\n                return self._add_reminder(**kwargs)\n            elif operation == \"get_reminders\":\n                return self._get_reminders(**kwargs)\n            elif operation == \"mark_completed\":\n                return self._mark_completed(**kwargs)\n            elif operation == \"update_reminder\":\n                return self._update_reminder(**kwargs)\n            elif operation == \"delete_reminder\":\n                return self._delete_reminder(**kwargs)\n            else:\n                raise ToolError(\n                    f\"Unknown operation: {operation}. Valid operations are: \"\n                    \"add_reminder, get_reminders, mark_completed, \"\n                    \"update_reminder, delete_reminder\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                )\n\n    def _add_reminder(\n        self,\n        title: str,\n        date: str,\n        description: Optional[str] = None,\n        contact_name: Optional[str] = None,\n        contact_email: Optional[str] = None,\n        contact_phone: Optional[str] = None,\n        additional_notes: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Add a new reminder with optional contact information.\n        \n        Args:\n            title: Brief title or subject of the reminder\n            date: When the reminder should occur (can be natural language like\n                \"tomorrow\" or \"in 3 weeks\")\n            description: Detailed description of the reminder\n            contact_name: Name of the contact associated with this reminder\n            contact_email: Email of the contact\n            contact_phone: Phone number of the contact\n            additional_notes: Any additional information to store with the reminder\n            \n        Returns:\n            Dict containing the created reminder\n            \n        Raises:\n            ToolError: If required fields are missing or date parsing fails\n        \"\"\"\n        self.logger.info(f\"Adding reminder: {title} for {date}\")\n        \n        # Validate required parameters\n        if not title:\n            raise ToolError(\n                \"Title is required for adding a reminder\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n            \n        if not date:\n            raise ToolError(\n                \"Date is required for adding a reminder\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n            \n        # Parse the date from natural language\n        try:\n            reminder_date = self._parse_date(date)\n        except Exception as e:\n            raise ToolError(\n                f\"Failed to parse date '{date}': {str(e)}\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n            \n        # Generate a unique ID for the reminder\n        import uuid\n        reminder_id = f\"rem_{uuid.uuid4().hex[:8]}\"\n        \n        # Check if contact name exists in customer database\n        customer_info = None\n        if contact_name:\n            customer_info = self._lookup_customer(contact_name)\n            \n        # Create the reminder object\n        reminder = Reminder(\n            id=reminder_id,\n            title=title,\n            description=description,\n            reminder_date=reminder_date,\n            created_at=datetime.now(),\n            completed=False,\n            contact_name=contact_name,\n            contact_email=contact_email,\n            contact_phone=contact_phone,\n            additional_notes=additional_notes\n        )\n        \n        # Update with customer info if available\n        if customer_info:\n            customer = customer_info.get(\"customer\", {})\n            reminder.customer_id = customer.get(\"id\")\n            \n            # Only update contact details if they weren't provided\n            if not contact_email and \"email_address\" in customer:\n                reminder.contact_email = customer.get(\"email_address\")\n                \n            if not contact_phone and \"phone_number\" in customer:\n                reminder.contact_phone = customer.get(\"phone_number\")\n        \n        # Save reminder to database\n        try:\n            self.db.add(reminder)\n            self.logger.info(f\"Added reminder with ID: {reminder_id}\")\n        except Exception as e:\n            self.logger.error(f\"Error saving reminder: {e}\")\n            raise ToolError(\n                f\"Failed to save reminder: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n            \n        # Prepare response\n        result = {\n            \"reminder\": reminder.to_dict(),\n            \"message\": f\"Reminder added for {reminder_date.strftime('%Y-%m-%d')}\"\n        }\n        \n        # Add customer details to response if found\n        if customer_info:\n            result[\"customer_found\"] = True\n            result[\"customer_info\"] = customer_info.get(\"customer\", {})\n            result[\"message\"] += f\" with contact information for {contact_name}\"\n        elif contact_name:\n            result[\"customer_found\"] = False\n            result[\"message\"] += f\". No customer record found for {contact_name}.\"\n            \n        return result\n\n    def _get_reminders(\n        self,\n        date_type: str,\n        specific_date: Optional[str] = None,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get reminders based on date criteria.\n        \n        Args:\n            date_type: Type of date query (\"today\", \"tomorrow\", \"upcoming\", \"past\",\n                \"all\", \"date\", \"range\")\n            specific_date: Specific date string (required if date_type is \"date\")\n            start_date: Start date string (required if date_type is \"range\")\n            end_date: End date string (required if date_type is \"range\")\n            \n        Returns:\n            Dict containing list of reminders matching the criteria\n            \n        Raises:\n            ToolError: If parameters are invalid or missing required fields\n        \"\"\"\n        self.logger.info(f\"Getting reminders with date_type: {date_type}\")\n        \n        # Validate date_type\n        valid_date_types = [\"today\", \"tomorrow\", \"upcoming\", \"past\", \"all\", \"date\", \"range\"]\n        if date_type not in valid_date_types:\n            raise ToolError(\n                f\"Invalid date_type: {date_type}. Must be one of {valid_date_types}\",\n                ErrorCode.TOOL_INVALID_INPUT\n            )\n            \n        # Process date types\n        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)\n        \n        with self.db.get_session() as session:\n            query = session.query(Reminder)\n            \n            # Apply date filters based on date_type\n            if date_type == \"today\":\n                tomorrow = today + timedelta(days=1)\n                query = query.filter(\n                    Reminder.reminder_date >= today,\n                    Reminder.reminder_date < tomorrow\n                )\n                date_description = \"today\"\n                \n            elif date_type == \"tomorrow\":\n                tomorrow = today + timedelta(days=1)\n                day_after = tomorrow + timedelta(days=1)\n                query = query.filter(\n                    Reminder.reminder_date >= tomorrow,\n                    Reminder.reminder_date < day_after\n                )\n                date_description = \"tomorrow\"\n                \n            elif date_type == \"upcoming\":\n                query = query.filter(\n                    Reminder.reminder_date >= today,\n                    Reminder.completed.is_(False)\n                )\n                date_description = \"upcoming\"\n                \n            elif date_type == \"past\":\n                query = query.filter(\n                    Reminder.reminder_date < today\n                )\n                date_description = \"past\"\n                \n            elif date_type == \"all\":\n                # No filter needed\n                date_description = \"all\"\n                \n            elif date_type == \"date\":\n                if not specific_date:\n                    raise ToolError(\n                        \"specific_date is required when date_type is 'date'\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                \n                try:\n                    parsed_date = self._parse_date(specific_date)\n                    next_date = parsed_date + timedelta(days=1)\n                    query = query.filter(\n                        Reminder.reminder_date >= parsed_date,\n                        Reminder.reminder_date < next_date\n                    )\n                    date_description = f\"on {parsed_date.strftime('%Y-%m-%d')}\"\n                except Exception as e:\n                    raise ToolError(\n                        f\"Failed to parse specific_date '{specific_date}': {str(e)}\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                \n            elif date_type == \"range\":\n                if not start_date or not end_date:\n                    raise ToolError(\n                        \"start_date and end_date are required when date_type is 'range'\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n                \n                try:\n                    parsed_start = self._parse_date(start_date)\n                    # Include end date fully\n                    parsed_end = self._parse_date(end_date) + timedelta(days=1)\n                    query = query.filter(\n                        Reminder.reminder_date >= parsed_start,\n                        Reminder.reminder_date < parsed_end\n                    )\n                    date_description = (\n                        f\"from {parsed_start.strftime('%Y-%m-%d')} \"\n                        f\"to {parsed_end.strftime('%Y-%m-%d')}\"\n                    )\n                except Exception as e:\n                    raise ToolError(\n                        f\"Failed to parse date range: {str(e)}\",\n                        ErrorCode.TOOL_INVALID_INPUT\n                    )\n            \n            # Sort by reminder date\n            query = query.order_by(Reminder.reminder_date)\n            \n            # Execute query and format results\n            reminders = query.all()\n            reminder_list = [reminder.to_dict() for reminder in reminders]\n            \n            return {\n                \"reminders\": reminder_list,\n                \"count\": len(reminder_list),\n                \"date_type\": date_type,\n                \"message\": f\"Found {len(reminder_list)} reminder(s) {date_description}\"\n            }\n\n    def _mark_completed(self, reminder_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Mark a reminder as completed.\n        \n        Args:\n            reminder_id: ID of the reminder to mark as completed\n            \n        Returns:\n            Dict containing the updated reminder\n            \n        Raises:\n            ToolError: If reminder_id is invalid or not found\n        \"\"\"\n        self.logger.info(f\"Marking reminder {reminder_id} as completed\")\n        \n        # Get the reminder\n        reminder = self.db.get(Reminder, reminder_id)\n        if not reminder:\n            raise ToolError(\n                f\"Reminder with ID '{reminder_id}' not found\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n            \n        # Update reminder\n        reminder.completed = True\n        reminder.completed_at = datetime.now()\n        \n        # Save changes\n        try:\n            self.db.update(reminder)\n            self.logger.info(f\"Marked reminder {reminder_id} as completed\")\n        except Exception as e:\n            self.logger.error(f\"Error updating reminder: {e}\")\n            raise ToolError(\n                f\"Failed to update reminder: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n            \n        return {\n            \"reminder\": reminder.to_dict(),\n            \"message\": f\"Reminder '{reminder.title}' marked as completed\"\n        }\n\n    def _update_reminder(\n        self,\n        reminder_id: str,\n        title: Optional[str] = None,\n        date: Optional[str] = None,\n        description: Optional[str] = None,\n        contact_name: Optional[str] = None,\n        contact_email: Optional[str] = None,\n        contact_phone: Optional[str] = None,\n        additional_notes: Optional[str] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Update an existing reminder.\n        \n        Args:\n            reminder_id: ID of the reminder to update\n            title: New title (optional)\n            date: New date (optional)\n            description: New description (optional)\n            contact_name: New contact name (optional)\n            contact_email: New contact email (optional)\n            contact_phone: New contact phone (optional)\n            additional_notes: New additional notes (optional)\n            \n        Returns:\n            Dict containing the updated reminder\n            \n        Raises:\n            ToolError: If reminder_id is invalid or not found\n        \"\"\"\n        self.logger.info(f\"Updating reminder {reminder_id}\")\n        \n        # Get the reminder\n        reminder = self.db.get(Reminder, reminder_id)\n        if not reminder:\n            raise ToolError(\n                f\"Reminder with ID '{reminder_id}' not found\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n            \n        # Update fields if provided\n        changes = []\n        \n        if title is not None:\n            reminder.title = title\n            changes.append(\"title\")\n            \n        if date is not None:\n            try:\n                reminder.reminder_date = self._parse_date(date)\n                changes.append(\"date\")\n            except Exception as e:\n                raise ToolError(\n                    f\"Failed to parse date '{date}': {str(e)}\",\n                    ErrorCode.TOOL_INVALID_INPUT\n                )\n                \n        if description is not None:\n            reminder.description = description\n            changes.append(\"description\")\n        \n        # Contact information updates\n        if contact_name is not None:\n            reminder.contact_name = contact_name\n            changes.append(\"contact_name\")\n            \n            # Lookup customer if name was updated\n            customer_info = self._lookup_customer(contact_name)\n            if customer_info:\n                customer = customer_info.get(\"customer\", {})\n                reminder.customer_id = customer.get(\"id\")\n                \n                # Only update these if not explicitly provided\n                if contact_email is None and \"email_address\" in customer:\n                    reminder.contact_email = customer.get(\"email_address\")\n                    changes.append(\"contact_email\")\n                    \n                if contact_phone is None and \"phone_number\" in customer:\n                    reminder.contact_phone = customer.get(\"phone_number\")\n                    changes.append(\"contact_phone\")\n        \n        if contact_email is not None:\n            reminder.contact_email = contact_email\n            changes.append(\"contact_email\")\n            \n        if contact_phone is not None:\n            reminder.contact_phone = contact_phone\n            changes.append(\"contact_phone\")\n            \n        if additional_notes is not None:\n            reminder.additional_notes = additional_notes\n            changes.append(\"additional_notes\")\n            \n        # Save changes\n        if changes:\n            try:\n                self.db.update(reminder)\n                self.logger.info(f\"Updated reminder {reminder_id} ({', '.join(changes)})\")\n            except Exception as e:\n                self.logger.error(f\"Error updating reminder: {e}\")\n                raise ToolError(\n                    f\"Failed to update reminder: {str(e)}\",\n                    ErrorCode.TOOL_EXECUTION_ERROR\n                )\n                \n        return {\n            \"reminder\": reminder.to_dict(),\n            \"updated_fields\": changes,\n            \"message\": (\n                f\"Reminder updated: {', '.join(changes)}\" if changes\n                else \"No changes made to reminder\"\n            )\n        }\n\n    def _delete_reminder(self, reminder_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Delete a reminder.\n        \n        Args:\n            reminder_id: ID of the reminder to delete\n            \n        Returns:\n            Dict containing deletion confirmation\n            \n        Raises:\n            ToolError: If reminder_id is invalid or not found\n        \"\"\"\n        self.logger.info(f\"Deleting reminder {reminder_id}\")\n        \n        # Get the reminder\n        reminder = self.db.get(Reminder, reminder_id)\n        if not reminder:\n            raise ToolError(\n                f\"Reminder with ID '{reminder_id}' not found\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n            \n        # Store title for confirmation message\n        title = reminder.title\n        \n        # Delete reminder\n        try:\n            self.db.delete(reminder)\n            self.logger.info(f\"Deleted reminder {reminder_id}\")\n        except Exception as e:\n            self.logger.error(f\"Error deleting reminder: {e}\")\n            raise ToolError(\n                f\"Failed to delete reminder: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR\n            )\n            \n        return {\n            \"id\": reminder_id,\n            \"message\": f\"Reminder '{title}' deleted successfully\"\n        }\n\n    def _parse_date(self, date_str: str) -> datetime:\n        \"\"\"\n        Parse a date string into a datetime object, supporting natural language.\n        \n        Args:\n            date_str: Date string in various formats (\"tomorrow\", \"next Friday\",\n                \"2025-05-01\", etc.)\n            \n        Returns:\n            datetime object representing the parsed date\n            \n        Raises:\n            ValueError: If date parsing fails\n        \"\"\"\n        today = datetime.now().replace(hour=12, minute=0, second=0, microsecond=0)\n        \n        # Handle some common natural language cases\n        date_str = date_str.lower().strip()\n        \n        if date_str == \"today\":\n            return today\n            \n        if date_str == \"tomorrow\":\n            return today + timedelta(days=1)\n            \n        if date_str.startswith(\"in \"):\n            # Handle \"in X days/weeks/months/years\" format\n            parts = date_str.split()\n            if len(parts) >= 3:\n                try:\n                    amount = int(parts[1])\n                    unit = parts[2].lower()\n                    \n                    if unit.startswith(\"day\"):\n                        return today + timedelta(days=amount)\n                    elif unit.startswith(\"week\"):\n                        return today + timedelta(weeks=amount)\n                    elif unit.startswith(\"month\"):\n                        return today + relativedelta(months=amount)\n                    elif unit.startswith(\"year\"):\n                        return today + relativedelta(years=amount)\n                except ValueError:\n                    pass  # Fall back to dateutil parser\n        \n        # Use dateutil for more complex cases\n        try:\n            return date_parser.parse(date_str, fuzzy=True)\n        except Exception as e:\n            raise ValueError(f\"Could not parse date: {date_str}. Error: {str(e)}\")\n\n    def _lookup_customer(self, name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Lookup a customer by name in the customer database.\n        \n        Args:\n            name: Customer name to search for\n            \n        Returns:\n            Dict with customer info or None if not found\n        \"\"\"\n        try:\n            # Import here to avoid circular imports\n            from tools.customerdatabase_tool import CustomerDatabaseTool\n            \n            # Create database tool instance\n            customer_tool = CustomerDatabaseTool()\n            \n            # Search for customer by name\n            return customer_tool.search_customers(query=name, category=\"name\")\n        except Exception as e:\n            self.logger.warning(f\"Customer lookup failed: {e}\")\n            return None",
  "description": "A tool for managing scheduled reminders with customer contact integration, allowing users to create, retrieve, and manage reminders with specific dates, details, and contact information stored in a SQLite database.",
  "operations": [
    {
      "name": "add_reminder",
      "description": "Creates a new reminder with a date, description, and optional contact information, automatically integrating with customer database when contact names are provided.",
      "required_parameters": [
        {
          "name": "title",
          "type": "string",
          "description": "Brief title or subject of the reminder"
        },
        {
          "name": "date",
          "type": "string",
          "description": "When the reminder should occur (can be natural language like 'tomorrow' or 'in 3 weeks')"
        }
      ],
      "optional_parameters": [
        {
          "name": "description",
          "type": "string",
          "description": "Detailed description of the reminder",
          "default": null
        },
        {
          "name": "contact_name",
          "type": "string",
          "description": "Name of the contact associated with this reminder",
          "default": null
        },
        {
          "name": "contact_email",
          "type": "string",
          "description": "Email of the contact",
          "default": null
        },
        {
          "name": "contact_phone",
          "type": "string",
          "description": "Phone number of the contact",
          "default": null
        },
        {
          "name": "additional_notes",
          "type": "string",
          "description": "Any additional information to store with the reminder",
          "default": null
        }
      ]
    },
    {
      "name": "get_reminders",
      "description": "Retrieves reminders based on specified date criteria, returning a list of reminders matching the criteria.",
      "required_parameters": [
        {
          "name": "date_type",
          "type": "string",
          "description": "Type of date query ('today', 'tomorrow', 'upcoming', 'past', 'all', 'date', or 'range')"
        }
      ],
      "optional_parameters": [
        {
          "name": "specific_date",
          "type": "string",
          "description": "Specific date string (required if date_type is 'date')",
          "default": null
        },
        {
          "name": "start_date",
          "type": "string",
          "description": "Start date string (required if date_type is 'range')",
          "default": null
        },
        {
          "name": "end_date",
          "type": "string",
          "description": "End date string (required if date_type is 'range')",
          "default": null
        }
      ]
    },
    {
      "name": "mark_completed",
      "description": "Marks a reminder as completed by setting its completed status to true and recording the completion time.",
      "required_parameters": [
        {
          "name": "reminder_id",
          "type": "string",
          "description": "ID of the reminder to mark as completed"
        }
      ],
      "optional_parameters": []
    },
    {
      "name": "update_reminder",
      "description": "Updates an existing reminder's details, including title, date, description, and contact information.",
      "required_parameters": [
        {
          "name": "reminder_id",
          "type": "string",
          "description": "ID of the reminder to update"
        }
      ],
      "optional_parameters": [
        {
          "name": "title",
          "type": "string",
          "description": "New title for the reminder",
          "default": null
        },
        {
          "name": "date",
          "type": "string",
          "description": "New date for the reminder",
          "default": null
        },
        {
          "name": "description",
          "type": "string",
          "description": "New description for the reminder",
          "default": null
        },
        {
          "name": "contact_name",
          "type": "string",
          "description": "New contact name",
          "default": null
        },
        {
          "name": "contact_email",
          "type": "string",
          "description": "New contact email",
          "default": null
        },
        {
          "name": "contact_phone",
          "type": "string",
          "description": "New contact phone",
          "default": null
        },
        {
          "name": "additional_notes",
          "type": "string",
          "description": "New additional notes",
          "default": null
        }
      ]
    },
    {
      "name": "delete_reminder",
      "description": "Removes a reminder from the database permanently.",
      "required_parameters": [
        {
          "name": "reminder_id",
          "type": "string",
          "description": "ID of the reminder to delete"
        }
      ],
      "optional_parameters": []
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}