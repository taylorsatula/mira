{
  "tool_name": "calendar_tool",
  "tool_code": "\"\"\"\nCalendar Tool for viewing and managing events across multiple calendar services.\n\nThis module provides a unified interface for accessing different types of calendars\n(CalDAV, iCalendar URLs) and performing operations like reading events, creating\nevents, and managing calendars.\n\"\"\"\n\nimport logging\nimport os\nimport json\nimport hashlib\nimport time\nimport uuid\nimport requests\nfrom typing import Dict, List, Any, Optional, Union, Type\nfrom datetime import datetime, timedelta\nfrom abc import ABC, abstractmethod\n\nimport caldav\nfrom pydantic import BaseModel, Field\nfrom tools.repo import Tool\nfrom errors import ErrorCode, error_context, ToolError\nfrom config.registry import registry\n\n\n# Define configuration classes\nclass CalendarEntry(BaseModel):\n    \"\"\"Configuration for a single calendar entry.\"\"\"\n    name: str = Field(description=\"User-friendly name for the calendar\")\n    url: str = Field(description=\"URL to the calendar (CalDAV server or iCalendar URL)\")\n    type: str = Field(description=\"Type of calendar: 'caldav' or 'ical'\")\n    username: Optional[str] = Field(None, description=\"Username for CalDAV authentication (if type is 'caldav')\")\n    calendar_id: Optional[str] = Field(None, description=\"Calendar ID for CalDAV server (if type is 'caldav')\")\n\n\nclass CalendarToolConfig(BaseModel):\n    \"\"\"Configuration for the calendar_tool.\"\"\"\n    enabled: bool = Field(default=True, description=\"Whether this tool is enabled by default\")\n    calendars: Dict[str, CalendarEntry] = Field(\n        default={},\n        description=\"Dictionary of calendar entries keyed by unique identifier\"\n    )\n    default_calendar_url: str = Field(\n        default=\"https://calendar.google.com/calendar/ical/a8hin9meea2nnatan6f87837ig%40group.calendar.google.com/private-2c4208fb60a802fb80b83f73b034201d/basic.ics\",\n        description=\"Default iCalendar URL to use (for simple configuration)\"\n    )\n    default_url: str = Field(\n        default=\"\",\n        description=\"Default CalDAV server URL\"\n    )\n    default_username: str = Field(\n        default=\"\",\n        description=\"Default CalDAV username\"\n    )\n    default_calendar_id: str = Field(\n        default=\"\",\n        description=\"Default calendar ID to use when not specified\"\n    )\n    timeout: int = Field(\n        default=30,\n        description=\"Timeout in seconds for CalDAV requests\"\n    )\n    max_events: int = Field(\n        default=100,\n        description=\"Maximum number of events to return in a single request\"\n    )\n    default_event_duration: int = Field(\n        default=60,\n        description=\"Default event duration in minutes if not specified\"\n    )\n    default_date_range: int = Field(\n        default=7,\n        description=\"Default number of days to look ahead when listing events\"\n    )\n    cache_directory: str = Field(\n        default=\"data/calendar_tool\",\n        description=\"Directory to store cached calendar data\"\n    )\n    cache_duration: int = Field(\n        default=3600,\n        description=\"Duration in seconds to cache iCalendar data (default: 1 hour)\"\n    )\n\n\n# Register with registry\nregistry.register(\"calendar_tool\", CalendarToolConfig)\n\n\nclass ValidationUtils:\n    \"\"\"Utility methods for validating calendar tool parameters.\"\"\"\n    \n    @staticmethod\n    def validate_date(date_str: Optional[str], param_name: str) -> Optional[datetime]:\n        \"\"\"\n        Validate and convert a date string to a datetime object.\n        \n        Args:\n            date_str: The date string in ISO format (YYYY-MM-DD)\n            param_name: The parameter name for error messages\n            \n        Returns:\n            A datetime object if valid, or None if date_str is None\n            \n        Raises:\n            ToolError: If the date is invalid\n        \"\"\"\n        if date_str is None:\n            return None\n            \n        if not isinstance(date_str, str):\n            raise ToolError(\n                f\"{param_name} must be a string in ISO format (YYYY-MM-DD)\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {param_name: date_str}\n            )\n            \n        try:\n            return datetime.fromisoformat(date_str)\n        except ValueError:\n            raise ToolError(\n                f\"Invalid {param_name} format: '{date_str}'. Use ISO format (YYYY-MM-DD)\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {param_name: date_str}\n            )\n    \n    @staticmethod\n    def validate_datetime(dt_str: Optional[str], param_name: str) -> Optional[datetime]:\n        \"\"\"\n        Validate and convert a datetime string to a datetime object.\n        \n        Args:\n            dt_str: The datetime string in ISO format (YYYY-MM-DDTHH:MM:SS)\n            param_name: The parameter name for error messages\n            \n        Returns:\n            A datetime object if valid, or None if dt_str is None\n            \n        Raises:\n            ToolError: If the datetime is invalid\n        \"\"\"\n        if dt_str is None:\n            return None\n            \n        if not isinstance(dt_str, str):\n            raise ToolError(\n                f\"{param_name} must be a string in ISO format (YYYY-MM-DDTHH:MM:SS)\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {param_name: dt_str}\n            )\n            \n        try:\n            return datetime.fromisoformat(dt_str)\n        except ValueError:\n            raise ToolError(\n                f\"Invalid {param_name} format: '{dt_str}'. Use ISO format (YYYY-MM-DDTHH:MM:SS)\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {param_name: dt_str}\n            )\n\n    @staticmethod\n    def require_non_empty_string(value: Any, param_name: str) -> str:\n        \"\"\"\n        Validate that a parameter is a non-empty string.\n        \n        Args:\n            value: The value to validate\n            param_name: The parameter name for error messages\n            \n        Returns:\n            The value if valid\n            \n        Raises:\n            ToolError: If the value is not a non-empty string\n        \"\"\"\n        if not value or not isinstance(value, str):\n            raise ToolError(\n                f\"{param_name} must be a non-empty string\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {param_name: value}\n            )\n        return value\n\n\nclass CalendarCache:\n    \"\"\"Handles caching of calendar data.\"\"\"\n    \n    def __init__(self, cache_dir: str, cache_duration: int):\n        \"\"\"\n        Initialize the cache manager.\n        \n        Args:\n            cache_dir: Directory to store cache files\n            cache_duration: Cache validity duration in seconds\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_duration = cache_duration\n        os.makedirs(cache_dir, exist_ok=True)\n        \n    def get_cache_path(self, key: str) -> str:\n        \"\"\"\n        Get the cache file path for a given key.\n        \n        Args:\n            key: The cache key (typically URL + date range)\n            \n        Returns:\n            The path to the cache file\n        \"\"\"\n        key_hash = hashlib.md5(key.encode()).hexdigest()\n        return os.path.join(self.cache_dir, f\"{key_hash}.json\")\n        \n    def is_valid(self, cache_path: str) -> bool:\n        \"\"\"\n        Check if a cache file is valid and not expired.\n        \n        Args:\n            cache_path: Path to the cache file\n            \n        Returns:\n            True if cache is valid, False otherwise\n        \"\"\"\n        if not os.path.exists(cache_path):\n            return False\n            \n        # Check if cache is expired\n        cache_age = time.time() - os.path.getmtime(cache_path)\n        return cache_age < self.cache_duration\n        \n    def get(self, key: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get data from cache if available and valid.\n        \n        Args:\n            key: The cache key\n            \n        Returns:\n            The cached data or None if not available\n        \"\"\"\n        cache_path = self.get_cache_path(key)\n        \n        if not self.is_valid(cache_path):\n            return None\n            \n        try:\n            with open(cache_path, 'r') as f:\n                return json.load(f)\n        except Exception as e:\n            logging.warning(f\"Failed to load cache for {key}: {str(e)}\")\n            return None\n            \n    def set(self, key: str, data: Dict[str, Any]) -> None:\n        \"\"\"\n        Save data to cache.\n        \n        Args:\n            key: The cache key\n            data: The data to cache\n        \"\"\"\n        cache_path = self.get_cache_path(key)\n        \n        try:\n            with open(cache_path, 'w') as f:\n                json.dump(data, f)\n        except Exception as e:\n            logging.warning(f\"Failed to cache data for {key}: {str(e)}\")\n\n\nclass CalendarProvider(ABC):\n    \"\"\"Abstract base class for calendar providers.\"\"\"\n    \n    def __init__(self, logger: logging.Logger):\n        \"\"\"\n        Initialize the calendar provider.\n        \n        Args:\n            logger: Logger instance for this provider\n        \"\"\"\n        self.logger = logger\n    \n    @abstractmethod\n    def get_events(self, start_date: Optional[str], end_date: Optional[str]) -> Dict[str, Any]:\n        \"\"\"\n        Get events from the calendar within a date range.\n        \n        Args:\n            start_date: Start date in ISO format (YYYY-MM-DD)\n            end_date: End date in ISO format (YYYY-MM-DD)\n            \n        Returns:\n            Dictionary with events data\n        \"\"\"\n        pass\n\n\nclass ICalProvider(CalendarProvider):\n    \"\"\"Provider for iCalendar URL calendars (read-only).\"\"\"\n    \n    def __init__(self, url: str, cache: CalendarCache, logger: logging.Logger, \n                 max_events: int = 100, default_date_range: int = 7):\n        \"\"\"\n        Initialize the iCalendar provider.\n        \n        Args:\n            url: The iCalendar URL\n            cache: Cache manager\n            logger: Logger instance\n            max_events: Maximum number of events to return\n            default_date_range: Default number of days to look ahead\n        \"\"\"\n        super().__init__(logger)\n        self.url = url\n        self.cache = cache\n        self.max_events = max_events\n        self.default_date_range = default_date_range\n        \n    def get_events(self, start_date: Optional[str] = None, end_date: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get events from the iCalendar URL.\n        \n        Args:\n            start_date: Start date in ISO format (YYYY-MM-DD)\n            end_date: End date in ISO format (YYYY-MM-DD)\n            \n        Returns:\n            Dictionary with events data\n        \"\"\"\n        # Validate and normalize dates\n        start_dt = ValidationUtils.validate_date(start_date, \"start_date\")\n        if not start_dt:\n            start_dt = datetime.now()\n            start_date = start_dt.date().isoformat()\n            \n        end_dt = ValidationUtils.validate_date(end_date, \"end_date\")\n        if not end_dt:\n            # Use default date range\n            end_dt = start_dt + timedelta(days=self.default_date_range)\n            end_date = end_dt.date().isoformat()\n        \n        # Use cache if available\n        cache_key = f\"{self.url}_{start_date}_{end_date}\"\n        cached_data = self.cache.get(cache_key)\n        if cached_data:\n            return cached_data\n        \n        # Fetch and parse the iCalendar data\n        try:\n            response = requests.get(self.url, timeout=30)\n            response.raise_for_status()\n            \n            # Parse the iCalendar content\n            calendar = caldav.lib.error.vcal.VCalendar(response.text)\n            \n            events = []\n            event_count = 0\n            \n            # Extract events from the calendar\n            for component in calendar.components():\n                if component.name == 'VEVENT':\n                    dtstart = component.get('dtstart')\n                    if not dtstart:\n                        continue\n                        \n                    # Get event start time\n                    event_start = dtstart.value\n                    \n                    # Skip events outside our date range\n                    if isinstance(event_start, datetime):\n                        event_date = event_start.date()\n                    else:\n                        # Handle all-day events\n                        event_date = event_start\n                        \n                    # Skip events outside our date range\n                    if event_date < start_dt.date() or event_date > end_dt.date():\n                        continue\n                        \n                    # Get event end time\n                    dtend = component.get('dtend')\n                    if dtend:\n                        event_end = dtend.value\n                    else:\n                        # Default to 1 hour for events without end time\n                        if isinstance(event_start, datetime):\n                            event_end = event_start + timedelta(hours=1)\n                        else:\n                            # All-day event\n                            event_end = event_start + timedelta(days=1)\n                    \n                    # Create event info\n                    event_info = {\n                        \"event_id\": str(component.get('uid', str(uuid.uuid4()))),\n                        \"summary\": str(component.get('summary', 'No Title')),\n                        \"start\": event_start.isoformat() if isinstance(event_start, datetime) else str(event_start),\n                        \"end\": event_end.isoformat() if isinstance(event_end, datetime) else str(event_end)\n                    }\n                    \n                    # Add optional properties if available\n                    if component.get('description'):\n                        event_info[\"description\"] = str(component.get('description'))\n                        \n                    if component.get('location'):\n                        event_info[\"location\"] = str(component.get('location'))\n                    \n                    events.append(event_info)\n                    event_count += 1\n                    \n                    # Limit the number of events to avoid overloading\n                    if event_count >= self.max_events:\n                        break\n            \n            result = {\n                \"events\": events,\n                \"count\": len(events),\n                \"calendar_id\": \"external\",\n                \"url\": self.url,\n                \"start_date\": start_date,\n                \"end_date\": end_date,\n                \"limited\": event_count >= self.max_events\n            }\n            \n            # Cache the result\n            self.cache.set(cache_key, result)\n            return result\n            \n        except requests.exceptions.RequestException as e:\n            raise ToolError(\n                f\"Failed to fetch iCalendar URL: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"url\": self.url, \"error\": str(e)}\n            )\n        except Exception as e:\n            raise ToolError(\n                f\"Failed to parse iCalendar data: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"url\": self.url, \"error\": str(e)}\n            )\n\n\nclass CalDAVProvider(CalendarProvider):\n    \"\"\"Provider for CalDAV calendars (read-write).\"\"\"\n    \n    def __init__(self, url: str, username: str, password: str, logger: logging.Logger, \n                 default_date_range: int = 7):\n        \"\"\"\n        Initialize the CalDAV provider.\n        \n        Args:\n            url: The CalDAV server URL\n            username: Username for authentication\n            password: Password for authentication\n            logger: Logger instance\n            default_date_range: Default number of days to look ahead\n        \"\"\"\n        super().__init__(logger)\n        self.url = url\n        self.username = username\n        self.password = password\n        self.default_date_range = default_date_range\n        self._client = None\n        \n    def _get_client(self) -> caldav.DAVClient:\n        \"\"\"\n        Get (or create) a CalDAV client.\n        \n        Returns:\n            A connected CalDAV client\n            \n        Raises:\n            ToolError: If connection fails\n        \"\"\"\n        if self._client:\n            return self._client\n            \n        try:\n            client = caldav.DAVClient(\n                url=self.url,\n                username=self.username,\n                password=self.password\n            )\n            # Test connection by getting principal\n            client.principal()\n            self._client = client\n            return client\n        except caldav.lib.error.AuthorizationError:\n            raise ToolError(\n                \"Authentication failed. Check your credentials.\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"url\": self.url, \"username\": self.username}\n            )\n        except Exception as e:\n            raise ToolError(\n                f\"Failed to connect to CalDAV server: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"url\": self.url, \"error\": str(e)}\n            )\n    \n    def _get_calendar(self, calendar_id: str) -> caldav.Calendar:\n        \"\"\"\n        Get a specific calendar by ID.\n        \n        Args:\n            calendar_id: The calendar ID\n            \n        Returns:\n            The calendar object\n            \n        Raises:\n            ToolError: If calendar is not found\n        \"\"\"\n        client = self._get_client()\n        \n        try:\n            principal = client.principal()\n            calendars = principal.calendars()\n            \n            for calendar in calendars:\n                if calendar.name == calendar_id:\n                    return calendar\n                    \n            raise ToolError(\n                f\"Calendar with ID '{calendar_id}' not found\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"calendar_id\": calendar_id}\n            )\n        except Exception as e:\n            if isinstance(e, ToolError):\n                raise\n            raise ToolError(\n                f\"Failed to access calendar: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"calendar_id\": calendar_id, \"error\": str(e)}\n            )\n    \n    def list_calendars(self) -> Dict[str, Any]:\n        \"\"\"\n        List available calendars.\n        \n        Returns:\n            Dictionary with list of calendars\n        \"\"\"\n        client = self._get_client()\n        \n        try:\n            principal = client.principal()\n            caldav_calendars = principal.calendars()\n            \n            calendar_list = []\n            for calendar in caldav_calendars:\n                cal_info = {\n                    \"id\": calendar.name,\n                    \"display_name\": calendar.get_properties([caldav.elements.dav.DisplayName()])[\"{DAV:}displayname\"] or calendar.name,\n                    \"url\": calendar.url\n                }\n                calendar_list.append(cal_info)\n            \n            return {\n                \"calendars\": calendar_list,\n                \"count\": len(calendar_list)\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Failed to list calendars: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"error\": str(e)}\n            )\n    \n    def get_events(self, calendar_id: str, start_date: Optional[str] = None, end_date: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get events from a calendar.\n        \n        Args:\n            calendar_id: The calendar ID\n            start_date: Start date in ISO format (YYYY-MM-DD)\n            end_date: End date in ISO format (YYYY-MM-DD)\n            \n        Returns:\n            Dictionary with events data\n        \"\"\"\n        # Validate and normalize dates\n        start_dt = ValidationUtils.validate_date(start_date, \"start_date\")\n        if not start_dt:\n            start_dt = datetime.now()\n            start_date = start_dt.date().isoformat()\n            \n        end_dt = ValidationUtils.validate_date(end_date, \"end_date\")\n        if not end_dt:\n            # Use default date range\n            end_dt = start_dt + timedelta(days=self.default_date_range)\n            end_date = end_dt.date().isoformat()\n            \n        calendar = self._get_calendar(calendar_id)\n        \n        try:\n            # Get events in the date range\n            events = calendar.date_search(\n                start=start_dt,\n                end=end_dt,\n                expand=True  # Expand recurring events\n            )\n            \n            event_list = []\n            for event in events:\n                ical_data = event.icalendar_component\n                \n                # Extract event details from iCalendar component\n                event_info = {\n                    \"event_id\": event.id,\n                    \"summary\": str(ical_data.get(\"summary\", \"No Title\")),\n                    \"start\": ical_data.get(\"dtstart\").dt.isoformat(),\n                    \"end\": ical_data.get(\"dtend\").dt.isoformat()\n                }\n                \n                # Add optional properties if available\n                if ical_data.get(\"description\"):\n                    event_info[\"description\"] = str(ical_data.get(\"description\"))\n                    \n                if ical_data.get(\"location\"):\n                    event_info[\"location\"] = str(ical_data.get(\"location\"))\n                \n                event_list.append(event_info)\n            \n            return {\n                \"events\": event_list,\n                \"count\": len(event_list),\n                \"calendar_id\": calendar_id,\n                \"start_date\": start_date,\n                \"end_date\": end_date\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Failed to get events: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"calendar_id\": calendar_id, \"error\": str(e)}\n            )\n    \n    def create_event(\n        self,\n        calendar_id: str,\n        summary: str,\n        start_time: str,\n        end_time: str,\n        description: Optional[str] = None,\n        location: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Create a new event.\n        \n        Args:\n            calendar_id: The calendar ID\n            summary: Event title\n            start_time: Event start time in ISO format\n            end_time: Event end time in ISO format\n            description: Optional event description\n            location: Optional event location\n            \n        Returns:\n            Dictionary with the created event\n        \"\"\"\n        # Validate parameters\n        ValidationUtils.require_non_empty_string(summary, \"summary\")\n        start_dt = ValidationUtils.validate_datetime(start_time, \"start_time\")\n        end_dt = ValidationUtils.validate_datetime(end_time, \"end_time\")\n        \n        if not start_dt or not end_dt:\n            raise ToolError(\n                \"Start and end times are required\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"start_time\": start_time, \"end_time\": end_time}\n            )\n            \n        if end_dt <= start_dt:\n            raise ToolError(\n                \"End time must be after start time\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"start_time\": start_time, \"end_time\": end_time}\n            )\n        \n        calendar = self._get_calendar(calendar_id)\n        \n        try:\n            # Create event\n            event_id = str(uuid.uuid4())\n            ical_data = f\"\"\"BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//MIRA//CalendarTool//EN\nBEGIN:VEVENT\nUID:{event_id}\nDTSTAMP:{datetime.now().strftime(\"%Y%m%dT%H%M%SZ\")}\nDTSTART:{start_dt.strftime(\"%Y%m%dT%H%M%S\")}\nDTEND:{end_dt.strftime(\"%Y%m%dT%H%M%S\")}\nSUMMARY:{summary}\"\"\"\n            \n            if description:\n                ical_data += f\"\\nDESCRIPTION:{description}\"\n                \n            if location:\n                ical_data += f\"\\nLOCATION:{location}\"\n                \n            ical_data += \"\"\"\\nEND:VEVENT\nEND:VCALENDAR\"\"\"\n            \n            # Add event to calendar\n            event = calendar.save_event(ical_data)\n            \n            return {\n                \"event\": {\n                    \"event_id\": event.id,\n                    \"summary\": summary,\n                    \"start\": start_time,\n                    \"end\": end_time,\n                    \"description\": description,\n                    \"location\": location\n                },\n                \"calendar_id\": calendar_id\n            }\n        except Exception as e:\n            raise ToolError(\n                f\"Failed to create event: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"calendar_id\": calendar_id, \"error\": str(e)}\n            )\n    \n    def delete_event(self, calendar_id: str, event_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Delete an event.\n        \n        Args:\n            calendar_id: The calendar ID\n            event_id: The event ID\n            \n        Returns:\n            Dictionary with deletion status\n        \"\"\"\n        # Validate parameters\n        ValidationUtils.require_non_empty_string(event_id, \"event_id\")\n        \n        calendar = self._get_calendar(calendar_id)\n        \n        try:\n            # Find the specific event\n            event = None\n            events = calendar.events()\n            \n            for e in events:\n                if e.id == event_id:\n                    event = e\n                    break\n            \n            if not event:\n                raise ToolError(\n                    f\"Event with ID '{event_id}' not found in calendar '{calendar_id}'\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"event_id\": event_id, \"calendar_id\": calendar_id}\n                )\n            \n            # Delete the event\n            event.delete()\n            \n            return {\n                \"event_id\": event_id,\n                \"calendar_id\": calendar_id,\n                \"deleted\": True\n            }\n        except Exception as e:\n            if isinstance(e, ToolError):\n                raise\n            raise ToolError(\n                f\"Failed to delete event: {str(e)}\",\n                ErrorCode.TOOL_EXECUTION_ERROR,\n                {\"calendar_id\": calendar_id, \"event_id\": event_id, \"error\": str(e)}\n            )\n\n\nclass CalendarTool(Tool):\n    \"\"\"\n    Calendar management tool for viewing and managing events.\n    \n    This tool provides functionality to view events across multiple calendars,\n    create new events, and manage existing appointments. It supports calendars\n    from various sources and provides a unified interface for accessing all\n    calendar information.\n    \"\"\"\n\n    name = \"calendar_tool\"\n    simple_description = \"\"\"\n    Manages calendar events for viewing appointments and scheduling. Use this tool when the user needs to check their calendar, \n    see upcoming events, or manage their personal appointments.\"\"\"\n    \n    implementation_details = \"\"\"\n    OPERATIONS:\n    - list_all_events: Lists events from all configured calendars within a date range\n      Parameters:\n        calendar_name (optional): Name of a specific calendar to query (if not provided, shows events from all configured calendars)\n        start_date (optional, default=today): Start date in ISO format (YYYY-MM-DD)\n        end_date (optional, default=7 days from start): End date in ISO format (YYYY-MM-DD)\n    \n    - list_calendars: Lists available calendars on the server\n      Parameters:\n        url (optional): The calendar server URL\n        username (optional): Username for authentication\n        password (optional): Password for authentication\n    \n    - list_events: Lists events from a specific calendar within a date range\n      Parameters:\n        url (optional): The calendar server URL\n        username (optional): Username for authentication\n        password (optional): Password for authentication\n        calendar_id (required): The calendar ID to query\n        start_date (optional, default=today): Start date in ISO format (YYYY-MM-DD)\n        end_date (optional, default=7 days from start): End date in ISO format (YYYY-MM-DD)\n    \n    - create_event: Creates a new calendar event\n      Parameters:\n        url (optional): The calendar server URL\n        username (optional): Username for authentication\n        password (optional): Password for authentication\n        calendar_id (required): The calendar ID to add the event to\n        summary (required): Event title/summary\n        start_time (required): Start time in ISO format (YYYY-MM-DDTHH:MM:SS)\n        end_time (required): End time in ISO format (YYYY-MM-DDTHH:MM:SS)\n        description (optional): Event description\n        location (optional): Event location\n    \n    - delete_event: Deletes a calendar event\n      Parameters:\n        url (optional): The calendar server URL\n        username (optional): Username for authentication\n        password (optional): Password for authentication\n        calendar_id (required): The calendar ID containing the event\n        event_id (required): The unique ID of the event to delete\n        \n    - read_ical_url: Reads events from a calendar URL\n      Parameters:\n        ical_url (optional): URL to the calendar file\n        start_date (optional, default=today): Start date in ISO format (YYYY-MM-DD)\n        end_date (optional, default=7 days from start): End date in ISO format (YYYY-MM-DD)\n    \n    RESPONSE FORMAT:\n    - All operations return a dictionary with success status and relevant data\n    - Events include summary, start/end times, and optional location and description\n    - Errors include detailed information about what went wrong\n    \n    USAGE NOTES:\n    - Calendars can be configured in the tool settings with user-friendly names\n    - Use list_all_events to see events from all configured calendars at once\n    - For viewing a specific calendar by name, use the calendar_name parameter\n    - Date ranges for listing events should be reasonable (e.g., 1-30 days)\n    - All date and time parameters must be in ISO format\n    - Calendar data is cached for improved performance\n    \n    LIMITATIONS:\n    - Some calendars may be read-only depending on their configuration\n    - Does not support recurring event creation (only displays them)\n    - Limited to basic event properties (no attachments, attendees, or notifications)\n    \"\"\"\n    \n    description = simple_description + implementation_details\n    \n    def __init__(self):\n        \"\"\"Initialize the calendar tool.\"\"\"\n        super().__init__()\n        self.logger.info(\"CalendarTool initialized\")\n        \n        # Get configuration\n        config = registry.get(\"calendar_tool\")\n        \n        # Create cache directory if it doesn't exist\n        self.cache = CalendarCache(config.cache_directory, config.cache_duration)\n        \n        # Store the config for later use\n        self.config = config\n        \n    def _create_caldav_provider(self, url: str, username: str, password: str) -> CalDAVProvider:\n        \"\"\"\n        Create a CalDAV provider instance.\n        \n        Args:\n            url: The CalDAV server URL\n            username: Username for authentication\n            password: Password for authentication\n            \n        Returns:\n            A configured CalDAV provider\n        \"\"\"\n        return CalDAVProvider(url, username, password, self.logger, \n                              default_date_range=self.config.default_date_range)\n        \n    def _create_ical_provider(self, url: str) -> ICalProvider:\n        \"\"\"\n        Create an iCalendar provider instance.\n        \n        Args:\n            url: The iCalendar URL\n            \n        Returns:\n            A configured iCalendar provider\n        \"\"\"\n        return ICalProvider(url, self.cache, self.logger, \n                           max_events=self.config.max_events,\n                           default_date_range=self.config.default_date_range)\n        \n    def _fetch_all_calendars(self, calendar_name: Optional[str] = None, start_date: Optional[str] = None, end_date: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Fetch events from all configured calendars.\n        \n        Args:\n            calendar_name: Optional name of a specific calendar to fetch\n            start_date: Start date in ISO format (YYYY-MM-DD)\n            end_date: End date in ISO format (YYYY-MM-DD)\n            \n        Returns:\n            Dictionary with events from all calendars\n        \"\"\"\n        # Set default date range if not provided\n        if not start_date:\n            start_date = datetime.now().date().isoformat()\n        \n        if not end_date:\n            # Get the default date range from config\n            days_ahead = self.config.default_date_range\n            \n            # Use the default date range\n            start_dt = datetime.fromisoformat(start_date)\n            end_dt = start_dt + timedelta(days=days_ahead)\n            end_date = end_dt.date().isoformat()\n        \n        # Get a list of calendars to fetch\n        calendars = dict(self.config.calendars)  # Make a copy\n        \n        # Check if there's a default calendar URL configured - if so, add it to the list\n        if self.config.default_calendar_url:\n            # Create a CalendarEntry for the default URL if it doesn't exist in calendars\n            default_url = self.config.default_calendar_url\n            default_entry = CalendarEntry(\n                name=\"Default Calendar\",\n                url=default_url,\n                type=\"ical\"\n            )\n            # Add to calendars if not already present\n            if \"default\" not in calendars:\n                calendars[\"default\"] = default_entry\n        \n        if not calendars:\n            # No calendars configured, return empty result\n            return {\n                \"success\": True,\n                \"calendars\": [],\n                \"total_events\": 0,\n                \"start_date\": start_date,\n                \"end_date\": end_date,\n                \"message\": \"No calendars configured in settings\"\n            }\n        \n        # Filter by name if specified\n        if calendar_name:\n            # Find the calendar with the specified name\n            found_calendar = None\n            for calendar_id, calendar in calendars.items():\n                if calendar.name.lower() == calendar_name.lower():\n                    found_calendar = (calendar_id, calendar)\n                    break\n            \n            if not found_calendar:\n                raise ToolError(\n                    f\"Calendar with name '{calendar_name}' not found in configuration\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"calendar_name\": calendar_name}\n                )\n            \n            # Use only the specified calendar\n            calendars_to_fetch = {found_calendar[0]: found_calendar[1]}\n        else:\n            # Use all calendars\n            calendars_to_fetch = calendars\n        \n        # Fetch events from each calendar\n        calendar_results = []\n        total_events = 0\n        \n        # Get password from environment variable\n        password = os.environ.get(\"CALDAV_PASSWORD\", \"\")\n        \n        for calendar_id, calendar in calendars_to_fetch.items():\n            try:\n                # Determine how to fetch events based on calendar type\n                if calendar.type.lower() == 'ical':\n                    # Fetch from iCalendar URL\n                    provider = self._create_ical_provider(calendar.url)\n                    result = provider.get_events(start_date, end_date)\n                    \n                    calendar_result = {\n                        \"name\": calendar.name,\n                        \"events\": result[\"events\"],\n                        \"count\": result[\"count\"],\n                        \"type\": \"ical\"\n                    }\n                elif calendar.type.lower() == 'caldav':\n                    # Check for required fields\n                    if not calendar.username:\n                        raise ToolError(\n                            f\"Username required for CalDAV calendar '{calendar.name}'\",\n                            ErrorCode.TOOL_INVALID_INPUT,\n                            {\"calendar_name\": calendar.name}\n                        )\n                    \n                    if not calendar.calendar_id:\n                        raise ToolError(\n                            f\"Calendar ID required for CalDAV calendar '{calendar.name}'\",\n                            ErrorCode.TOOL_INVALID_INPUT,\n                            {\"calendar_name\": calendar.name}\n                        )\n                    \n                    # Fetch from CalDAV server\n                    provider = self._create_caldav_provider(calendar.url, calendar.username, password)\n                    result = provider.get_events(calendar.calendar_id, start_date, end_date)\n                    \n                    calendar_result = {\n                        \"name\": calendar.name,\n                        \"events\": result[\"events\"],\n                        \"count\": result[\"count\"],\n                        \"type\": \"caldav\"\n                    }\n                else:\n                    raise ToolError(\n                        f\"Invalid calendar type '{calendar.type}' for calendar '{calendar.name}'\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                        {\"calendar_name\": calendar.name, \"calendar_type\": calendar.type}\n                    )\n                \n                calendar_results.append(calendar_result)\n                total_events += calendar_result[\"count\"]\n                \n            except Exception as e:\n                # Log the error but continue with other calendars\n                self.logger.error(f\"Error fetching calendar '{calendar.name}': {str(e)}\")\n                calendar_result = {\n                    \"name\": calendar.name,\n                    \"events\": [],\n                    \"count\": 0,\n                    \"error\": str(e),\n                    \"type\": calendar.type\n                }\n                calendar_results.append(calendar_result)\n        \n        return {\n            \"success\": True,\n            \"calendars\": calendar_results,\n            \"total_events\": total_events,\n            \"start_date\": start_date,\n            \"end_date\": end_date\n        }\n\n    def run(\n        self,\n        action: str,\n        start_date: Optional[str] = None,\n        end_date: Optional[str] = None,\n        summary: Optional[str] = None,\n        start_time: Optional[str] = None,\n        end_time: Optional[str] = None,\n        description: Optional[str] = None,\n        location: Optional[str] = None,\n        event_id: Optional[str] = None,\n        ical_url: Optional[str] = None,\n        calendar_name: Optional[str] = None,\n        url: Optional[str] = None,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        calendar_id: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute the calendar tool with the specified action.\n        \n        Args:\n            action: The operation to perform (list_all_events, list_calendars, list_events, create_event, delete_event, read_ical_url)\n            start_date: Start date for listing events (YYYY-MM-DD)\n            end_date: End date for listing events (YYYY-MM-DD)\n            summary: Event title/summary for create_event\n            start_time: Event start time for create_event (YYYY-MM-DDTHH:MM:SS)\n            end_time: Event end time for create_event (YYYY-MM-DDTHH:MM:SS)\n            description: Event description for create_event\n            location: Event location for create_event\n            event_id: Event ID for delete_event\n            ical_url: URL to an iCalendar (.ics) file for read_ical_url\n            calendar_name: Name of a specific calendar for list_all_events\n            url: CalDAV server URL for direct operations\n            username: Username for CalDAV authentication\n            password: Password for CalDAV authentication\n            calendar_id: Calendar ID for CalDAV operations\n            \n        Returns:\n            Dictionary containing the operation results\n        \"\"\"\n        self.logger.info(f\"Running calendar tool with action: {action}\")\n        \n        with error_context(\n            component_name=self.name,\n            operation=f\"executing calendar operation '{action}'\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger\n        ):\n            if action == \"list_all_events\":\n                # Fetch events from all configured calendars\n                return self._fetch_all_calendars(calendar_name, start_date, end_date)\n                \n            elif action == \"read_ical_url\":\n                # If no ical_url provided, try to use the default calendar URL\n                if not ical_url:\n                    if self.config.default_calendar_url:\n                        ical_url = self.config.default_calendar_url\n                    else:\n                        raise ToolError(\n                            \"iCalendar URL must be provided or configured in settings\",\n                            ErrorCode.TOOL_INVALID_INPUT,\n                            {\"param\": \"ical_url\"}\n                        )\n                \n                ValidationUtils.require_non_empty_string(ical_url, \"ical_url\")\n                \n                # Create provider and fetch events\n                provider = self._create_ical_provider(ical_url)\n                result = provider.get_events(start_date, end_date)\n                \n                return {\n                    \"success\": True,\n                    **result\n                }\n                \n            else:\n                # For CalDAV operations, use provided parameters or defaults\n                srv_url = url or self.config.default_url\n                srv_username = username or self.config.default_username\n                srv_password = password or os.environ.get(\"CALDAV_PASSWORD\", \"\")\n                srv_calendar_id = calendar_id or self.config.default_calendar_id\n                \n                # Validate common parameters for CalDAV operations\n                ValidationUtils.require_non_empty_string(srv_url, \"url\")\n                ValidationUtils.require_non_empty_string(srv_username, \"username\")\n                ValidationUtils.require_non_empty_string(srv_password, \"password\")\n                \n                # Create provider\n                provider = self._create_caldav_provider(srv_url, srv_username, srv_password)\n                \n                # Route to appropriate action\n                if action == \"list_calendars\":\n                    result = provider.list_calendars()\n                    return {\n                        \"success\": True,\n                        **result\n                    }\n                    \n                elif action == \"list_events\":\n                    ValidationUtils.require_non_empty_string(srv_calendar_id, \"calendar_id\")\n                    result = provider.get_events(srv_calendar_id, start_date, end_date)\n                    return {\n                        \"success\": True,\n                        **result\n                    }\n                    \n                elif action == \"create_event\":\n                    ValidationUtils.require_non_empty_string(srv_calendar_id, \"calendar_id\")\n                    ValidationUtils.require_non_empty_string(summary, \"summary\")\n                    ValidationUtils.require_non_empty_string(start_time, \"start_time\")\n                    ValidationUtils.require_non_empty_string(end_time, \"end_time\")\n                    \n                    result = provider.create_event(\n                        srv_calendar_id, summary, start_time, end_time, description, location\n                    )\n                    return {\n                        \"success\": True,\n                        \"message\": \"Event created successfully\",\n                        **result\n                    }\n                    \n                elif action == \"delete_event\":\n                    ValidationUtils.require_non_empty_string(srv_calendar_id, \"calendar_id\")\n                    ValidationUtils.require_non_empty_string(event_id, \"event_id\")\n                    \n                    result = provider.delete_event(srv_calendar_id, event_id)\n                    return {\n                        \"success\": True,\n                        \"message\": \"Event deleted successfully\",\n                        **result\n                    }\n                    \n                else:\n                    raise ToolError(\n                        f\"Invalid action: {action}. Must be one of: list_all_events, list_calendars, list_events, create_event, delete_event, read_ical_url\",\n                        ErrorCode.TOOL_INVALID_INPUT,\n                        {\"provided_action\": action}\n                    )",
  "description": "A unified interface for viewing and managing events across multiple calendar services including CalDAV and iCalendar URLs.",
  "operations": [
    {
      "name": "list_all_events",
      "description": "Lists events from all configured calendars within a specified date range.",
      "required_parameters": [],
      "optional_parameters": [
        {
          "name": "calendar_name",
          "type": "string",
          "description": "Name of a specific calendar to query",
          "default": "None (all calendars)"
        },
        {
          "name": "start_date",
          "type": "string",
          "description": "Start date in ISO format (YYYY-MM-DD)",
          "default": "today"
        },
        {
          "name": "end_date",
          "type": "string",
          "description": "End date in ISO format (YYYY-MM-DD)",
          "default": "7 days from start_date"
        }
      ]
    },
    {
      "name": "read_ical_url",
      "description": "Reads events from a specified iCalendar URL within a date range.",
      "required_parameters": [],
      "optional_parameters": [
        {
          "name": "ical_url",
          "type": "string",
          "description": "URL to the iCalendar file",
          "default": "default_calendar_url from config"
        },
        {
          "name": "start_date",
          "type": "string",
          "description": "Start date in ISO format (YYYY-MM-DD)",
          "default": "today"
        },
        {
          "name": "end_date",
          "type": "string",
          "description": "End date in ISO format (YYYY-MM-DD)",
          "default": "7 days from start_date"
        }
      ]
    },
    {
      "name": "list_calendars",
      "description": "Lists all available calendars on a CalDAV server.",
      "required_parameters": [],
      "optional_parameters": [
        {
          "name": "url",
          "type": "string",
          "description": "The CalDAV server URL",
          "default": "default_url from config"
        },
        {
          "name": "username",
          "type": "string",
          "description": "Username for authentication",
          "default": "default_username from config"
        },
        {
          "name": "password",
          "type": "string",
          "description": "Password for authentication",
          "default": "CALDAV_PASSWORD environment variable"
        }
      ]
    },
    {
      "name": "list_events",
      "description": "Lists events from a specific calendar on a CalDAV server within a date range.",
      "required_parameters": [
        {
          "name": "calendar_id",
          "type": "string",
          "description": "The calendar ID to query"
        }
      ],
      "optional_parameters": [
        {
          "name": "url",
          "type": "string",
          "description": "The CalDAV server URL",
          "default": "default_url from config"
        },
        {
          "name": "username",
          "type": "string",
          "description": "Username for authentication",
          "default": "default_username from config"
        },
        {
          "name": "password",
          "type": "string",
          "description": "Password for authentication",
          "default": "CALDAV_PASSWORD environment variable"
        },
        {
          "name": "start_date",
          "type": "string",
          "description": "Start date in ISO format (YYYY-MM-DD)",
          "default": "today"
        },
        {
          "name": "end_date",
          "type": "string",
          "description": "End date in ISO format (YYYY-MM-DD)",
          "default": "7 days from start_date"
        }
      ]
    },
    {
      "name": "create_event",
      "description": "Creates a new calendar event on a CalDAV server.",
      "required_parameters": [
        {
          "name": "calendar_id",
          "type": "string",
          "description": "The calendar ID to add the event to"
        },
        {
          "name": "summary",
          "type": "string",
          "description": "Event title/summary"
        },
        {
          "name": "start_time",
          "type": "string",
          "description": "Start time in ISO format (YYYY-MM-DDTHH:MM:SS)"
        },
        {
          "name": "end_time",
          "type": "string",
          "description": "End time in ISO format (YYYY-MM-DDTHH:MM:SS)"
        }
      ],
      "optional_parameters": [
        {
          "name": "url",
          "type": "string",
          "description": "The CalDAV server URL",
          "default": "default_url from config"
        },
        {
          "name": "username",
          "type": "string",
          "description": "Username for authentication",
          "default": "default_username from config"
        },
        {
          "name": "password",
          "type": "string",
          "description": "Password for authentication",
          "default": "CALDAV_PASSWORD environment variable"
        },
        {
          "name": "description",
          "type": "string",
          "description": "Event description",
          "default": "None"
        },
        {
          "name": "location",
          "type": "string",
          "description": "Event location",
          "default": "None"
        }
      ]
    },
    {
      "name": "delete_event",
      "description": "Deletes a calendar event from a CalDAV server.",
      "required_parameters": [
        {
          "name": "calendar_id",
          "type": "string",
          "description": "The calendar ID containing the event"
        },
        {
          "name": "event_id",
          "type": "string",
          "description": "The unique ID of the event to delete"
        }
      ],
      "optional_parameters": [
        {
          "name": "url",
          "type": "string",
          "description": "The CalDAV server URL",
          "default": "default_url from config"
        },
        {
          "name": "username",
          "type": "string",
          "description": "Username for authentication",
          "default": "default_username from config"
        },
        {
          "name": "password",
          "type": "string",
          "description": "Password for authentication",
          "default": "CALDAV_PASSWORD environment variable"
        }
      ]
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}