{
  "tool_name": "weather_tool",
  "tool_code": "\"\"\"\nWeather tool for retrieving forecast data and calculating heat stress indices.\n\nThis tool provides weather forecast information from OpenMeteo API and calculates\nWet Bulb Globe Temperature (WBGT) for heat stress assessment, which is particularly\nuseful for field technicians working in hot conditions.\n\"\"\"\n\n# Standard library imports\nimport logging\nimport json\nimport os\nimport hashlib\nimport time\nfrom typing import Dict, List, Any, Optional, Union, Set\nfrom datetime import datetime, timedelta\n\n# Third-party imports\nimport requests\nfrom pydantic import BaseModel, Field\n\n# Local imports\nfrom tools.repo import Tool\nfrom errors import ErrorCode, error_context, ToolError\nfrom config.registry import registry\n\n\n# -------------------- CONFIGURATION --------------------\n\nclass WeatherToolConfig(BaseModel):\n    \"\"\"\n    Configuration for the weather_tool.\n    \n    Defines the parameters that control the weather tool's behavior,\n    including API endpoints, caching, and default settings.\n    \"\"\"\n    # Standard configuration parameter - all tools should include this\n    enabled: bool = Field(\n        default=True, \n        description=\"Whether this tool is enabled by default\"\n    )\n    \n    # API configuration\n    api_endpoint: str = Field(\n        default=\"https://api.open-meteo.com/v1/forecast\", \n        description=\"The OpenMeteo API endpoint\"\n    )\n    \n    # Caching configuration\n    cache_enabled: bool = Field(\n        default=True, \n        description=\"Whether to cache weather data\"\n    )\n    cache_duration: int = Field(\n        default=3600, \n        description=\"Cache duration in seconds (default: 1 hour)\"\n    )\n    cache_directory: str = Field(\n        default=\"data/tools/weather_tool/cache\", \n        description=\"Directory to store cached weather data\"\n    )\n    \n    # Default parameters\n    timezone: str = Field(\n        default=\"auto\", \n        description=\"Default timezone (auto or IANA time zone name)\"\n    )\n    forecast_days: int = Field(\n        default=7, \n        description=\"Number of forecast days to retrieve\"\n    )\n    \n    # Heat stress risk thresholds (NIOSH/OSHA guidelines - in Celsius)\n    wbgt_risk_thresholds: Dict[str, float] = Field(\n        default={\n            \"low\": 0,\n            \"moderate\": 25.0,\n            \"high\": 27.8,\n            \"very_high\": 30.0,\n            \"extreme\": 32.2\n        },\n        description=\"WBGT thresholds for heat stress risk levels in Celsius\"\n    )\n\n# Register with registry\nregistry.register(\"weather_tool\", WeatherToolConfig)\n\n\n# -------------------- CACHE MANAGER --------------------\n\nclass WeatherCache:\n    \"\"\"\n    Manages caching of weather data to minimize API requests.\n    \"\"\"\n    \n    def __init__(self, cache_dir: str, cache_duration: int):\n        \"\"\"\n        Initialize the cache manager.\n        \n        Args:\n            cache_dir: Directory to store cache files\n            cache_duration: Cache validity duration in seconds\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.cache_duration = cache_duration\n        \n        # Create cache directory if it doesn't exist\n        os.makedirs(cache_dir, exist_ok=True)\n    \n    def get_cache_path(self, key: str) -> str:\n        \"\"\"\n        Get the cache file path for a given key.\n        \n        Args:\n            key: Cache key\n            \n        Returns:\n            Path to the cache file\n        \"\"\"\n        # Create a hash of the key for the filename to avoid invalid characters\n        key_hash = hashlib.md5(key.encode()).hexdigest()\n        return os.path.join(self.cache_dir, f\"{key_hash}.json\")\n    \n    def is_valid(self, cache_path: str) -> bool:\n        \"\"\"\n        Check if a cache file is valid and not expired.\n        \n        Args:\n            cache_path: Path to the cache file\n            \n        Returns:\n            True if cache is valid, False otherwise\n        \"\"\"\n        # Check if file exists\n        if not os.path.exists(cache_path):\n            return False\n            \n        # Check if cache is expired based on file modification time\n        cache_age = time.time() - os.path.getmtime(cache_path)\n        return cache_age < self.cache_duration\n    \n    def get(self, key: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get data from cache if available and valid.\n        \n        Args:\n            key: Cache key\n            \n        Returns:\n            Cached data or None if not available\n        \"\"\"\n        cache_path = self.get_cache_path(key)\n        \n        # Check if cache is valid\n        if not self.is_valid(cache_path):\n            return None\n            \n        # Read from cache\n        try:\n            with open(cache_path, 'r') as f:\n                return json.load(f)\n        except Exception as e:\n            logging.warning(f\"Failed to load cache for {key}: {str(e)}\")\n            return None\n    \n    def set(self, key: str, data: Dict[str, Any]) -> None:\n        \"\"\"\n        Save data to cache.\n        \n        Args:\n            key: Cache key\n            data: Data to cache\n        \"\"\"\n        cache_path = self.get_cache_path(key)\n        \n        try:\n            with open(cache_path, 'w') as f:\n                json.dump(data, f, indent=2)\n        except Exception as e:\n            logging.warning(f\"Failed to cache data for {key}: {str(e)}\")\n\n\n# -------------------- VALIDATION FUNCTIONS --------------------\n\nclass ValidationUtils:\n    \"\"\"\n    Utility methods for validating weather tool parameters.\n    \"\"\"\n    \n    @staticmethod\n    def validate_coordinates(latitude: Any, longitude: Any) -> tuple:\n        \"\"\"\n        Validate latitude and longitude coordinates.\n        \n        Args:\n            latitude: Latitude value to validate\n            longitude: Longitude value to validate\n            \n        Returns:\n            Tuple of validated (latitude, longitude)\n            \n        Raises:\n            ToolError: If coordinates are invalid\n        \"\"\"\n        errors = {}\n        \n        # Check if latitude is missing or invalid\n        if latitude is None:\n            errors[\"latitude\"] = \"Latitude is required\"\n        else:\n            try:\n                lat_float = float(latitude)\n                if lat_float < -90 or lat_float > 90:\n                    errors[\"latitude\"] = f\"Latitude must be between -90 and 90, got {lat_float}\"\n                latitude = lat_float\n            except (ValueError, TypeError):\n                errors[\"latitude\"] = f\"Latitude must be a valid number, got {type(latitude).__name__}: {latitude}\"\n        \n        # Check if longitude is missing or invalid\n        if longitude is None:\n            errors[\"longitude\"] = \"Longitude is required\"\n        else:\n            try:\n                lon_float = float(longitude)\n                if lon_float < -180 or lon_float > 180:\n                    errors[\"longitude\"] = f\"Longitude must be between -180 and 180, got {lon_float}\"\n                longitude = lon_float\n            except (ValueError, TypeError):\n                errors[\"longitude\"] = f\"Longitude must be a valid number, got {type(longitude).__name__}: {longitude}\"\n        \n        # If there are any errors, raise exception\n        if errors:\n            error_message = \"; \".join(f\"{key}: {value}\" for key, value in errors.items())\n            raise ToolError(\n                error_message,\n                ErrorCode.TOOL_INVALID_INPUT,\n                errors\n            )\n        \n        return (latitude, longitude)\n    \n    @staticmethod\n    def validate_date(date_str: Optional[str]) -> Optional[str]:\n        \"\"\"\n        Validate a date string for forecasts.\n        \n        Args:\n            date_str: Date string in ISO format (YYYY-MM-DD)\n            \n        Returns:\n            Validated date string or None\n            \n        Raises:\n            ToolError: If date is invalid\n        \"\"\"\n        # Allow None value\n        if date_str is None:\n            return None\n            \n        # Check if parameter is a string\n        if not isinstance(date_str, str):\n            raise ToolError(\n                f\"Date must be a string in ISO format (YYYY-MM-DD)\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"date\": date_str}\n            )\n            \n        try:\n            # Parse date in ISO format\n            date_obj = datetime.fromisoformat(date_str)\n            \n            # Ensure date is not too far in the future\n            max_days = 16  # OpenMeteo typically supports up to 16 days\n            if date_obj.date() > datetime.now().date() + timedelta(days=max_days):\n                raise ToolError(\n                    f\"Date cannot be more than {max_days} days in the future\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"date\": date_str, \"max_days\": max_days}\n                )\n                \n            # Return the validated date string\n            return date_str\n        except ValueError:\n            raise ToolError(\n                f\"Invalid date format: '{date_str}'. Use ISO format (YYYY-MM-DD)\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"date\": date_str}\n            )\n    \n    @staticmethod\n    def validate_parameters(parameters: Optional[Union[str, List[str]]]) -> Optional[List[str]]:\n        \"\"\"\n        Validate requested weather parameters.\n        \n        Args:\n            parameters: List of parameters or comma-separated string\n            \n        Returns:\n            List of validated parameters or None for all parameters\n            \n        Raises:\n            ToolError: If parameters are invalid\n        \"\"\"\n        # If None, return None (all parameters)\n        if parameters is None:\n            return None\n        \n        # If string, split by comma\n        if isinstance(parameters, str):\n            # Empty string means all parameters\n            if not parameters.strip():\n                return None\n            parameters = [p.strip() for p in parameters.split(',')]\n        \n        # Validate it's a list\n        if not isinstance(parameters, list):\n            raise ToolError(\n                f\"Parameters must be a list or comma-separated string, got {type(parameters).__name__}\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"parameters\": parameters}\n            )\n        \n        # Check if list is empty\n        if not parameters:\n            return None\n        \n        # Validate each parameter is a string\n        for i, param in enumerate(parameters):\n            if not isinstance(param, str):\n                raise ToolError(\n                    f\"Parameter at index {i} must be a string, got {type(param).__name__}\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"parameter\": param}\n                )\n        \n        # Return list of validated parameters\n        return parameters\n    \n    @staticmethod\n    def validate_forecast_type(forecast_type: Optional[str]) -> str:\n        \"\"\"\n        Validate the forecast type parameter.\n        \n        Args:\n            forecast_type: Type of forecast to retrieve (hourly, daily)\n            \n        Returns:\n            Validated forecast type\n            \n        Raises:\n            ToolError: If forecast type is invalid\n        \"\"\"\n        valid_types = [\"hourly\", \"daily\"]\n        \n        if not forecast_type:\n            return \"hourly\"  # Default\n        \n        if not isinstance(forecast_type, str):\n            raise ToolError(\n                f\"Forecast type must be a string, got {type(forecast_type).__name__}\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"forecast_type\": forecast_type}\n            )\n        \n        forecast_type = forecast_type.lower()\n        \n        if forecast_type not in valid_types:\n            raise ToolError(\n                f\"Invalid forecast type: {forecast_type}. Must be one of: {', '.join(valid_types)}\",\n                ErrorCode.TOOL_INVALID_INPUT,\n                {\"forecast_type\": forecast_type, \"valid_types\": valid_types}\n            )\n        \n        return forecast_type\n\n\n# -------------------- MAIN TOOL CLASS --------------------\n\nclass WeatherTool(Tool):\n    \"\"\"\n    Tool for retrieving weather forecast data and calculating heat stress indices.\n    \n    This tool provides weather forecast information from OpenMeteo API and calculates\n    Wet Bulb Globe Temperature (WBGT) for heat stress assessment, particularly\n    useful for field technicians working outdoors in hot conditions.\n    \"\"\"\n    \n    name = \"weather_tool\"\n    \n    description = \"\"\"\n    Retrieves weather forecast data and calculates heat stress indices for specified locations.\n    Use this tool to get weather forecasts, heat stress information, and related data for planning\n    field work activities based on expected weather conditions.\n    \n    OPERATIONS:\n    - get_forecast: Retrieves weather forecast data for a specific location\n      Parameters:\n        latitude (required): Latitude of the location (-90 to 90)\n        longitude (required): Longitude of the location (-180 to 180)\n        forecast_type (optional): Type of forecast to retrieve (hourly, daily). Default is hourly.\n        date (optional): Specific date for forecast in ISO format (YYYY-MM-DD). If not provided, returns forecast from current date.\n        parameters (optional): Specific parameters to retrieve, comma-separated or as a list. If not provided, returns all available parameters.\n        \n    - get_heat_stress: Retrieves weather data and calculates heat stress indices for a specific location\n      Parameters:\n        latitude (required): Latitude of the location (-90 to 90)\n        longitude (required): Longitude of the location (-180 to 180)\n        forecast_type (optional): Type of forecast to retrieve (hourly, daily). Default is hourly.\n        date (optional): Specific date for forecast in ISO format (YYYY-MM-DD). If not provided, returns forecast from current date.\n        parameters (optional): Additional specific parameters to retrieve beyond those needed for heat stress calculation.\n    \n    RESPONSE FORMAT:\n    - For get_forecast operations: Weather data including requested parameters\n    - For get_heat_stress operations: Weather data plus WBGT values and heat stress risk levels\n    \n    LIMITATIONS:\n    - Forecasts are limited to 7 days into the future\n    - Historical data is not available through this tool\n    - Heat stress calculations are approximations and should be used as guidance, not as definitive safety indicators\n    - Some parameters may not be available for all locations or time periods\n    \"\"\"\n    \n    # Common hourly parameters available in the API\n    _available_hourly_params = [\n        \"temperature_2m\", \"relative_humidity_2m\", \"dew_point_2m\", \"apparent_temperature\",\n        \"precipitation_probability\", \"precipitation\", \"rain\", \"showers\", \"snowfall\",\n        \"snow_depth\", \"weather_code\", \"pressure_msl\", \"surface_pressure\", \"cloud_cover\",\n        \"cloud_cover_low\", \"cloud_cover_mid\", \"cloud_cover_high\", \"visibility\",\n        \"evapotranspiration\", \"reference_evapotranspiration\", \"vapor_pressure_deficit\",\n        \"wind_speed_10m\", \"wind_speed_80m\", \"wind_speed_120m\", \"wind_speed_180m\",\n        \"wind_direction_10m\", \"wind_direction_80m\", \"wind_direction_120m\", \"wind_direction_180m\",\n        \"wind_gusts_10m\", \"temperature_80m\", \"temperature_120m\", \"temperature_180m\",\n        \"soil_temperature_0cm\", \"soil_temperature_6cm\", \"soil_temperature_18cm\",\n        \"soil_temperature_54cm\", \"soil_moisture_0_1cm\", \"soil_moisture_1_3cm\",\n        \"soil_moisture_3_9cm\", \"soil_moisture_9_27cm\", \"soil_moisture_27_81cm\",\n        \"shortwave_radiation\", \"direct_radiation\", \"direct_normal_irradiance\",\n        \"diffuse_radiation\", \"global_tilted_irradiance\", \"terrestrial_radiation\",\n        \"shortwave_radiation_instant\", \"direct_radiation_instant\", \"direct_normal_irradiance_instant\",\n        \"diffuse_radiation_instant\", \"global_tilted_irradiance_instant\", \"terrestrial_radiation_instant\",\n        \"is_day\", \"wet_bulb_temperature_2m\", \"sunshine_duration\"\n    ]\n    \n    # Common daily parameters available in the API\n    _available_daily_params = [\n        \"weather_code\", \"temperature_2m_max\", \"temperature_2m_min\", \"temperature_2m_mean\",\n        \"apparent_temperature_max\", \"apparent_temperature_min\", \"apparent_temperature_mean\",\n        \"sunrise\", \"sunset\", \"daylight_duration\", \"sunshine_duration\", \"precipitation_sum\",\n        \"rain_sum\", \"snowfall_sum\", \"precipitation_hours\", \"precipitation_probability_max\",\n        \"precipitation_probability_min\", \"precipitation_probability_mean\", \"wind_speed_10m_max\",\n        \"wind_gusts_10m_max\", \"wind_direction_10m_dominant\", \"shortwave_radiation_sum\",\n        \"et0_fao_evapotranspiration\", \"uv_index_max\", \"uv_index_clear_sky_max\",\n        \"wind_speed_10m_mean\"\n    ]\n    \n    # Parameters required for WBGT calculation\n    _wbgt_required_params = [\n        \"temperature_2m\", \"wet_bulb_temperature_2m\", \n        \"shortwave_radiation\", \"wind_speed_10m\"\n    ]\n    \n    usage_examples = [\n        {\n            \"input\": {\n                \"operation\": \"get_forecast\",\n                \"latitude\": 34.7304,\n                \"longitude\": -86.5859,\n                \"forecast_type\": \"hourly\",\n                \"parameters\": \"temperature_2m,precipitation,wind_speed_10m\"\n            },\n            \"output\": {\n                \"success\": True,\n                \"location\": {\n                    \"latitude\": 34.7304,\n                    \"longitude\": -86.5859\n                },\n                \"forecast_type\": \"hourly\",\n                \"forecast\": {\n                    \"hourly\": {\n                        \"time\": [\"2025-05-06T00:00\", \"2025-05-06T01:00\"],\n                        \"temperature_2m\": [12.7, 12.2],\n                        \"precipitation\": [0, 0],\n                        \"wind_speed_10m\": [6.7, 6.6]\n                    },\n                    \"hourly_units\": {\n                        \"temperature_2m\": \"\u00b0C\",\n                        \"precipitation\": \"mm\",\n                        \"wind_speed_10m\": \"km/h\"\n                    }\n                }\n            }\n        },\n        {\n            \"input\": {\n                \"operation\": \"get_heat_stress\",\n                \"latitude\": 34.7304,\n                \"longitude\": -86.5859\n            },\n            \"output\": {\n                \"success\": True,\n                \"location\": {\n                    \"latitude\": 34.7304,\n                    \"longitude\": -86.5859\n                },\n                \"forecast_type\": \"hourly\",\n                \"forecast\": {\n                    \"hourly\": {\n                        \"time\": [\"2025-05-06T12:00\", \"2025-05-06T13:00\"],\n                        \"temperature_2m\": [20.6, 21.4],\n                        \"wet_bulb_temperature_2m\": [14.9, 15.0],\n                        \"shortwave_radiation\": [955.0, 997.5],\n                        \"wind_speed_10m\": [4.0, 2.2],\n                        \"wbgt\": [16.2, 17.1],\n                        \"heat_stress_risk\": [\"Low\", \"Low\"]\n                    },\n                    \"hourly_units\": {\n                        \"temperature_2m\": \"\u00b0C\",\n                        \"wet_bulb_temperature_2m\": \"\u00b0C\",\n                        \"shortwave_radiation\": \"W/m\u00b2\",\n                        \"wind_speed_10m\": \"km/h\",\n                        \"wbgt\": \"\u00b0C\"\n                    }\n                }\n            }\n        }\n    ]\n    \n    def __init__(self):\n        \"\"\"Initialize the weather tool.\"\"\"\n        super().__init__()\n        self.logger.info(\"WeatherTool initialized\")\n        \n        # Create required directories\n        from config import config\n        os.makedirs(config.weather_tool.cache_directory, exist_ok=True)\n    \n    def run(\n        self,\n        operation: str,\n        latitude: Union[float, str],\n        longitude: Union[float, str],\n        forecast_type: Optional[str] = None,\n        date: Optional[str] = None,\n        parameters: Optional[Union[str, List[str]]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Execute the weather tool with the specified operation.\n        \n        Args:\n            operation: The operation to perform (get_forecast, get_heat_stress)\n            latitude: Latitude of the location (-90 to 90)\n            longitude: Longitude of the location (-180 to 180)\n            forecast_type: Type of forecast to retrieve (hourly, daily)\n            date: Specific date for forecast in ISO format (YYYY-MM-DD)\n            parameters: Specific parameters to retrieve (comma-separated or list)\n            \n        Returns:\n            Dictionary containing the operation results\n            \n        Raises:\n            ToolError: If parameters are invalid or the operation fails\n        \"\"\"\n        self.logger.info(f\"Running weather tool with operation: {operation}\")\n        \n        with error_context(\n            component_name=self.name,\n            operation=f\"performing {operation} operation\",\n            error_class=ToolError,\n            error_code=ErrorCode.TOOL_EXECUTION_ERROR,\n            logger=self.logger\n        ):\n            # Import config inside the method to avoid circular imports\n            from config import config\n            \n            # Validate common parameters\n            lat, lon = ValidationUtils.validate_coordinates(latitude, longitude)\n            forecast_type = ValidationUtils.validate_forecast_type(forecast_type)\n            validated_date = ValidationUtils.validate_date(date)\n            validated_params = ValidationUtils.validate_parameters(parameters)\n            \n            # Execute appropriate operation\n            if operation == \"get_forecast\":\n                result = self._get_forecast(lat, lon, forecast_type, validated_date, validated_params)\n            elif operation == \"get_heat_stress\":\n                result = self._get_heat_stress(lat, lon, forecast_type, validated_date, validated_params)\n            else:\n                raise ToolError(\n                    f\"Invalid operation: {operation}. Must be one of: get_forecast, get_heat_stress\",\n                    ErrorCode.TOOL_INVALID_INPUT,\n                    {\"operation\": operation}\n                )\n            \n            return {\n                \"success\": True,\n                **result\n            }\n    \n    def _get_weather_data(\n        self,\n        latitude: float,\n        longitude: float,\n        forecast_type: str,\n        date: Optional[str] = None,\n        parameters: Optional[List[str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get weather data from OpenMeteo API with caching.\n        \n        Args:\n            latitude: Latitude of the location\n            longitude: Longitude of the location\n            forecast_type: Type of forecast to retrieve (hourly, daily)\n            date: Specific date for forecast\n            parameters: Specific parameters to retrieve\n            \n        Returns:\n            Dictionary with API response data\n            \n        Raises:\n            ToolError: If API request fails\n        \"\"\"\n        from config import config\n        \n        # Create cache key\n        cache_key = f\"{latitude}_{longitude}_{forecast_type}\"\n        if date:\n            cache_key += f\"_{date}\"\n        if parameters:\n            cache_key += f\"_{','.join(sorted(parameters))}\"\n        \n        # Create cache if enabled\n        if config.weather_tool.cache_enabled:\n            cache = WeatherCache(config.weather_tool.cache_directory, config.weather_tool.cache_duration)\n            cached_data = cache.get(cache_key)\n            if cached_data:\n                self.logger.info(f\"Using cached weather data for: {cache_key}\")\n                return cached_data\n        \n        # Determine parameters to request\n        hourly_params = []\n        daily_params = []\n        \n        if parameters is None:\n            # Default parameters if none specified\n            if forecast_type == \"hourly\":\n                hourly_params = self._available_hourly_params\n            else:  # daily\n                daily_params = self._available_daily_params\n        else:\n            # Requested parameters\n            if forecast_type == \"hourly\":\n                hourly_params = [p for p in parameters if p in self._available_hourly_params]\n            else:  # daily\n                daily_params = [p for p in parameters if p in self._available_daily_params]\n        \n        # Ensure we have parameters to request\n        if forecast_type == \"hourly\" and not hourly_params:\n            self.logger.warning(\"No valid hourly parameters specified, using defaults\")\n            hourly_params = [\"temperature_2m\", \"precipitation_probability\", \"wind_speed_10m\"]\n        elif forecast_type == \"daily\" and not daily_params:\n            self.logger.warning(\"No valid daily parameters specified, using defaults\")\n            daily_params = [\"temperature_2m_max\", \"temperature_2m_min\", \"precipitation_sum\"]\n        \n        # Build API request URL\n        url = config.weather_tool.api_endpoint\n        params = {\n            \"latitude\": latitude,\n            \"longitude\": longitude,\n            \"timezone\": config.weather_tool.timezone,\n            \"forecast_days\": config.weather_tool.forecast_days\n        }\n        \n        # Add parameters\n        if hourly_params:\n            params[\"hourly\"] = \",\".join(hourly_params)\n        if daily_params:\n            params[\"daily\"] = \",\".join(daily_params)\n        \n        # Filter to specific date if provided\n        if date:\n            params[\"start_date\"] = date\n            params[\"end_date\"] = date\n        \n        # Make API request\n        self.logger.info(f\"Requesting weather data from OpenMeteo API: {url} with params: {params}\")\n        \n        try:\n            response = requests.get(url, params=params, timeout=30)\n            response.raise_for_status()\n            data = response.json()\n            \n            # Cache if enabled\n            if config.weather_tool.cache_enabled:\n                cache.set(cache_key, data)\n            \n            return data\n        except requests.RequestException as e:\n            raise ToolError(\n                f\"Failed to fetch weather data: {str(e)}\",\n                ErrorCode.API_CONNECTION_ERROR,\n                {\"url\": url, \"params\": params, \"error\": str(e)}\n            )\n        except (ValueError, KeyError) as e:\n            raise ToolError(\n                f\"Invalid response from weather API: {str(e)}\",\n                ErrorCode.API_RESPONSE_ERROR,\n                {\"error\": str(e)}\n            )\n    \n    def _get_forecast(\n        self,\n        latitude: float,\n        longitude: float,\n        forecast_type: str,\n        date: Optional[str] = None,\n        parameters: Optional[List[str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get weather forecast data from OpenMeteo API.\n        \n        Args:\n            latitude: Latitude of the location\n            longitude: Longitude of the location\n            forecast_type: Type of forecast to retrieve\n            date: Specific date for forecast\n            parameters: Specific parameters to retrieve\n            \n        Returns:\n            Dictionary with weather forecast data\n        \"\"\"\n        self.logger.info(f\"Getting {forecast_type} forecast for coordinates: {latitude}, {longitude}\")\n        \n        # Get weather data\n        weather_data = self._get_weather_data(latitude, longitude, forecast_type, date, parameters)\n        \n        # Return formatted response\n        return {\n            \"location\": {\n                \"latitude\": weather_data.get(\"latitude\", latitude),\n                \"longitude\": weather_data.get(\"longitude\", longitude),\n                \"elevation\": weather_data.get(\"elevation\"),\n                \"timezone\": weather_data.get(\"timezone\")\n            },\n            \"forecast_type\": forecast_type,\n            \"forecast\": {\n                # Include units if available\n                f\"{forecast_type}_units\": weather_data.get(f\"{forecast_type}_units\", {}),\n                \n                # Include forecast data\n                forecast_type: weather_data.get(forecast_type, {})\n            }\n        }\n    \n    def _get_heat_stress(\n        self,\n        latitude: float,\n        longitude: float,\n        forecast_type: str,\n        date: Optional[str] = None,\n        parameters: Optional[List[str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get weather forecast and calculate heat stress indices.\n        \n        Args:\n            latitude: Latitude of the location\n            longitude: Longitude of the location\n            forecast_type: Type of forecast to retrieve\n            date: Specific date for forecast\n            parameters: Additional parameters to retrieve\n            \n        Returns:\n            Dictionary with weather forecast and heat stress data\n        \"\"\"\n        self.logger.info(f\"Calculating heat stress for coordinates: {latitude}, {longitude}\")\n        \n        # Only hourly forecasts support WBGT calculation\n        if forecast_type != \"hourly\":\n            self.logger.warning(\"Heat stress calculation requires hourly forecast, switching from daily\")\n            forecast_type = \"hourly\"\n        \n        # Ensure we request the parameters needed for WBGT calculation\n        required_params = set(self._wbgt_required_params)\n        requested_params = set(parameters or [])\n        combined_params = list(required_params.union(requested_params))\n        \n        # Get weather data with required parameters\n        weather_data = self._get_weather_data(latitude, longitude, forecast_type, date, combined_params)\n        \n        # Extract required data for WBGT calculation\n        hourly_data = weather_data.get(\"hourly\", {})\n        if not all(param in hourly_data for param in self._wbgt_required_params):\n            missing_params = [param for param in self._wbgt_required_params if param not in hourly_data]\n            raise ToolError(\n                f\"Missing required parameters for WBGT calculation: {missing_params}\",\n                ErrorCode.API_RESPONSE_ERROR,\n                {\"missing_params\": missing_params}\n            )\n        \n        # Calculate WBGT and heat stress risk\n        times = hourly_data.get(\"time\", [])\n        temp_2m = hourly_data.get(\"temperature_2m\", [])\n        wet_bulb_temp = hourly_data.get(\"wet_bulb_temperature_2m\", [])\n        radiation = hourly_data.get(\"shortwave_radiation\", [])\n        wind_speed = hourly_data.get(\"wind_speed_10m\", [])\n        \n        wbgt_values = []\n        risk_levels = []\n        \n        for i in range(len(times)):\n            # Calculate WBGT\n            wbgt = self._calculate_wbgt(\n                wet_bulb_temp[i],\n                temp_2m[i],\n                radiation[i],\n                wind_speed[i]\n            )\n            wbgt_values.append(round(wbgt, 1))\n            \n            # Determine risk level\n            risk_level = self._get_heat_stress_risk_level(wbgt)\n            risk_levels.append(risk_level)\n        \n        # Add WBGT and risk levels to hourly data\n        hourly_data[\"wbgt\"] = wbgt_values\n        hourly_data[\"heat_stress_risk\"] = risk_levels\n        \n        # Add WBGT unit to units\n        hourly_units = weather_data.get(\"hourly_units\", {})\n        hourly_units[\"wbgt\"] = \"\u00b0C\"\n        \n        # Return formatted response\n        return {\n            \"location\": {\n                \"latitude\": weather_data.get(\"latitude\", latitude),\n                \"longitude\": weather_data.get(\"longitude\", longitude),\n                \"elevation\": weather_data.get(\"elevation\"),\n                \"timezone\": weather_data.get(\"timezone\")\n            },\n            \"forecast_type\": forecast_type,\n            \"forecast\": {\n                \"hourly_units\": hourly_units,\n                \"hourly\": hourly_data\n            }\n        }\n    \n    def _calculate_wbgt(\n        self,\n        wet_bulb_temperature: float,\n        temperature: float,\n        shortwave_radiation: float,\n        wind_speed: float\n    ) -> float:\n        \"\"\"\n        Calculate Wet Bulb Globe Temperature (WBGT) for heat stress assessment.\n        \n        WBGT = 0.7 \u00d7 wet_bulb_temperature_2m + \n               0.3 \u00d7 temperature_2m + \n               0.14 \u00d7 (shortwave_radiation/1000) - \n               0.016 \u00d7 wind_speed_10m\n        \n        Args:\n            wet_bulb_temperature: Wet bulb temperature in \u00b0C\n            temperature: Temperature in \u00b0C\n            shortwave_radiation: Shortwave radiation in W/m\u00b2\n            wind_speed: Wind speed in km/h\n            \n        Returns:\n            WBGT value in \u00b0C\n        \"\"\"\n        # Apply the WBGT formula\n        wbgt = (\n            0.7 * wet_bulb_temperature +\n            0.3 * temperature +\n            0.14 * (shortwave_radiation / 1000) -\n            0.016 * wind_speed\n        )\n        \n        return wbgt\n    \n    def _get_heat_stress_risk_level(self, wbgt: float) -> str:\n        \"\"\"\n        Determine heat stress risk level based on WBGT value according to NIOSH/OSHA guidelines.\n        \n        Args:\n            wbgt: WBGT value in \u00b0C\n            \n        Returns:\n            Risk level (Low, Moderate, High, Very High, Extreme)\n        \"\"\"\n        from config import config\n        \n        # Get thresholds from config\n        thresholds = config.weather_tool.wbgt_risk_thresholds\n        \n        # Determine risk level based on thresholds\n        if wbgt < thresholds[\"moderate\"]:\n            return \"Low\"\n        elif wbgt < thresholds[\"high\"]:\n            return \"Moderate\"\n        elif wbgt < thresholds[\"very_high\"]:\n            return \"High\"\n        elif wbgt < thresholds[\"extreme\"]:\n            return \"Very High\"\n        else:\n            return \"Extreme\"",
  "description": "A tool for retrieving weather forecast data from OpenMeteo API and calculating Wet Bulb Globe Temperature (WBGT) for heat stress assessment, particularly useful for field technicians working outdoors in hot conditions.",
  "operations": [
    {
      "name": "get_forecast",
      "description": "Retrieves weather forecast data for a specific location with customizable parameters and forecast types.",
      "required_parameters": [
        {
          "name": "latitude",
          "type": "float or string",
          "description": "Latitude of the location (-90 to 90)"
        },
        {
          "name": "longitude",
          "type": "float or string",
          "description": "Longitude of the location (-180 to 180)"
        }
      ],
      "optional_parameters": [
        {
          "name": "forecast_type",
          "type": "string",
          "description": "Type of forecast to retrieve (hourly, daily)",
          "default": "hourly"
        },
        {
          "name": "date",
          "type": "string",
          "description": "Specific date for forecast in ISO format (YYYY-MM-DD)",
          "default": "null (current date)"
        },
        {
          "name": "parameters",
          "type": "string or list",
          "description": "Specific weather parameters to retrieve, comma-separated or as a list",
          "default": "null (all available parameters)"
        }
      ]
    },
    {
      "name": "get_heat_stress",
      "description": "Retrieves weather data and calculates heat stress indices (WBGT) for a specific location, providing risk level assessments based on NIOSH/OSHA guidelines.",
      "required_parameters": [
        {
          "name": "latitude",
          "type": "float or string",
          "description": "Latitude of the location (-90 to 90)"
        },
        {
          "name": "longitude",
          "type": "float or string",
          "description": "Longitude of the location (-180 to 180)"
        }
      ],
      "optional_parameters": [
        {
          "name": "forecast_type",
          "type": "string",
          "description": "Type of forecast to retrieve (hourly, daily) - note that heat stress calculation requires hourly data",
          "default": "hourly"
        },
        {
          "name": "date",
          "type": "string",
          "description": "Specific date for forecast in ISO format (YYYY-MM-DD)",
          "default": "null (current date)"
        },
        {
          "name": "parameters",
          "type": "string or list",
          "description": "Additional specific parameters to retrieve beyond those needed for heat stress calculation",
          "default": "null (only required parameters)"
        }
      ]
    }
  ],
  "complexity_category": "standard",
  "recommended_examples": 45
}