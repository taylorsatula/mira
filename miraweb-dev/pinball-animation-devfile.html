<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinball Plunger Input Animation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            margin: 0;
            padding: 50px;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 30px;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 5px;
            display: none;
        }

        .debug-info.active {
            display: block;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .controls button {
            padding: 8px 15px;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .controls button:hover {
            background: #555;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 280px;
        }

        .control-group label {
            font-size: 13px;
            min-width: 110px;
            font-weight: 600;
        }

        .control-slider {
            width: 120px;
        }

        .control-value {
            font-size: 13px;
            font-weight: 600;
            min-width: 45px;
            text-align: right;
        }

        .control-select {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .values-display {
            background: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            margin-top: 5px;
            border: 1px solid #ddd;
        }

        .input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
            width: 400px;
        }

        .input-container {
            position: relative;
            flex: 1;
            z-index: 5;
        }

        .input-container.firing {
            z-index: 10;
        }

        .input-field {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #333;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            background: white;
            color: rgba(0, 0, 0, 1);
            position: relative;
            z-index: 2;
            box-sizing: border-box;
            transition: none;
        }

        .send-button {
            padding: 15px 25px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
        }

        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .message-projectile {
            position: absolute;
            top: 2px;
            left: 20px;
            right: 20px;
            font-size: 16px;
            color: #000;
            pointer-events: none;
            z-index: 3;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.4;
            will-change: transform, opacity;
            padding-top: 0;
            /* Clip-path that allows upward movement but clips below the starting position */
            clip-path: polygon(0 -500px, 100% -500px, 100% 50px, 0 50px);
        }

        /* Visual guide lines for debug mode */
        .guide-lines {
            position: fixed;
            left: 0;
            right: 0;
            pointer-events: none;
            display: none;
        }

        .guide-lines.active {
            display: block;
        }

        .guide-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(255, 0, 0, 0.3);
        }

        .guide-line::after {
            content: attr(data-label);
            position: absolute;
            right: 10px;
            top: -10px;
            font-size: 10px;
            color: #666;
            font-family: monospace;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
        }

        .toggle-button {
            padding: 6px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .toggle-button.active {
            background: #28a745;
        }

        .toggle-button:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-row">
            <button onclick="toggleDebug()">Toggle Debug</button>
            <button id="autoRepeatBtn" class="toggle-button" onclick="toggleAutoRepeat()">Auto Repeat: OFF</button>
        </div>
        
        <div class="control-group">
            <label for="durationSlider">Duration:</label>
            <input type="range" id="durationSlider" class="control-slider" min="500" max="4000" value="1400" step="100">
            <span id="durationValue" class="control-value">1.4s</span>
        </div>

        <div class="control-group">
            <label for="pullbackSlider">Pullback:</label>
            <input type="range" id="pullbackSlider" class="control-slider" min="0" max="20" value="7" step="1">
            <span id="pullbackValue" class="control-value">7px</span>
        </div>

        <div class="control-group">
            <label for="launchSlider">Launch:</label>
            <input type="range" id="launchSlider" class="control-slider" min="-50" max="0" value="-2" step="1">
            <span id="launchValue" class="control-value">-2px</span>
        </div>

        <div class="control-group">
            <label for="returnStyle">Return Style:</label>
            <select id="returnStyle" class="control-select">
                <option value="linear">Linear</option>
                <option value="ease">Ease</option>
                <option value="ease-in" selected>Ease In</option>
                <option value="ease-out">Ease Out</option>
                <option value="ease-in-out">Ease In-Out</option>
                <option value="bounce">Bounce</option>
            </select>
        </div>

        <div class="values-display" id="valuesDisplay">
Current Settings:
Duration: 1.4s
Pullback: 7px
Launch: -2px
Return: ease-in
        </div>
    </div>

    <div class="debug-info" id="debugInfo"></div>
    
    <div class="guide-lines" id="guideLines">
        <div class="guide-line" data-label="Rest" style="top: 50%"></div>
        <div class="guide-line" data-label="Overshoot (+1px)" style="top: calc(50% + 1px); background: rgba(255, 165, 0, 0.3);"></div>
        <div class="guide-line" data-label="Text Start (Top Edge)" style="top: calc(50% - 25px); background: rgba(0, 255, 0, 0.3);"></div>
        <div class="guide-line" id="pullbackGuide" data-label="Pullback (+7px)" style="top: calc(50% + 7px)"></div>
        <div class="guide-line" id="launchGuide" data-label="Launch (-2px)" style="top: calc(50% - 2px)"></div>
        <div class="guide-line" data-label="Text Overtake (~-65px)" style="top: calc(50% - 65px); background: rgba(0, 0, 255, 0.3);"></div>
        <div class="guide-line" data-label="Text Target (-69px)" style="top: calc(50% - 69px)"></div>
    </div>

    <div class="input-wrapper">
        <div class="input-container" id="inputContainer">
            <input type="text" class="input-field" id="messageInput" placeholder="Type and send..." />
        </div>
        <button class="send-button" id="sendButton">Send</button>
    </div>

    <script>
        const inputContainer = document.getElementById('inputContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const debugInfo = document.getElementById('debugInfo');
        const guideLines = document.getElementById('guideLines');
        const durationSlider = document.getElementById('durationSlider');
        const durationValue = document.getElementById('durationValue');
        const pullbackSlider = document.getElementById('pullbackSlider');
        const pullbackValue = document.getElementById('pullbackValue');
        const launchSlider = document.getElementById('launchSlider');
        const launchValue = document.getElementById('launchValue');
        const returnStyle = document.getElementById('returnStyle');
        const valuesDisplay = document.getElementById('valuesDisplay');
        const autoRepeatBtn = document.getElementById('autoRepeatBtn');
        const pullbackGuide = document.getElementById('pullbackGuide');
        const launchGuide = document.getElementById('launchGuide');
        
        // Master animation settings
        let totalAnimationDuration = 1400;
        let pullbackDistance = 7;
        let launchDistance = -2;
        let returnEasing = 'ease-in';
        let debugMode = false;
        let autoRepeat = false;
        let autoRepeatInterval = null;

        const dummyTexts = [
            "Hello world!",
            "Testing animation",
            "Pinball plunger",
            "Message sent!",
            "Another test message",
            "Animation demo",
            "Looking good!",
            "Perfect timing"
        ];
        let dummyTextIndex = 0;

        // Update handlers
        durationSlider.addEventListener('input', (e) => {
            totalAnimationDuration = parseInt(e.target.value);
            durationValue.textContent = (totalAnimationDuration / 1000).toFixed(1) + 's';
            updateValuesDisplay();
        });

        pullbackSlider.addEventListener('input', (e) => {
            pullbackDistance = parseInt(e.target.value);
            pullbackValue.textContent = pullbackDistance + 'px';
            pullbackGuide.style.top = `calc(50% + ${pullbackDistance}px)`;
            pullbackGuide.setAttribute('data-label', `Pullback (+${pullbackDistance}px)`);
            updateValuesDisplay();
        });

        launchSlider.addEventListener('input', (e) => {
            launchDistance = parseInt(e.target.value);
            launchValue.textContent = launchDistance + 'px';
            launchGuide.style.top = `calc(50% + ${launchDistance}px)`;
            launchGuide.setAttribute('data-label', `Launch (${launchDistance}px)`);
            updateValuesDisplay();
        });

        returnStyle.addEventListener('change', (e) => {
            returnEasing = e.target.value;
            updateValuesDisplay();
        });

        function updateValuesDisplay() {
            valuesDisplay.textContent = `Current Settings:
Duration: ${(totalAnimationDuration / 1000).toFixed(1)}s
Pullback: ${pullbackDistance}px
Launch: ${launchDistance}px
Return: ${returnEasing}`;
        }

        function toggleDebug() {
            debugMode = !debugMode;
            debugInfo.classList.toggle('active', debugMode);
            guideLines.classList.toggle('active', debugMode);
        }

        function toggleAutoRepeat() {
            autoRepeat = !autoRepeat;
            autoRepeatBtn.textContent = `Auto Repeat: ${autoRepeat ? 'ON' : 'OFF'}`;
            autoRepeatBtn.classList.toggle('active', autoRepeat);
            
            if (autoRepeat) {
                // Start auto repeat
                runAutoRepeat();
            } else {
                // Stop auto repeat
                if (autoRepeatInterval) {
                    clearTimeout(autoRepeatInterval);
                    autoRepeatInterval = null;
                }
            }
        }

        function runAutoRepeat() {
            if (!autoRepeat) return;
            
            // Set dummy text
            messageInput.value = dummyTexts[dummyTextIndex];
            dummyTextIndex = (dummyTextIndex + 1) % dummyTexts.length;
            
            // Run animation
            sendMessage().then(() => {
                if (autoRepeat) {
                    autoRepeatInterval = setTimeout(runAutoRepeat, 3000);
                }
            });
        }

        function updateDebug(inputPos, textPos, phase) {
            if (!debugMode) return;
            debugInfo.innerHTML = `
                Phase: ${phase}<br>
                Input Pos: ${inputPos.toFixed(1)}px<br>
                Text Pos: ${textPos.toFixed(1)}px<br>
                Separation: ${(textPos - inputPos).toFixed(1)}px<br>
                Duration: ${(totalAnimationDuration / 1000).toFixed(1)}s
            `;
        }

        function getReturnEasing(t) {
            switch (returnEasing) {
                case 'linear':
                    return t;
                case 'ease':
                    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                case 'ease-in':
                    return t * t;
                case 'ease-out':
                    return t * (2 - t);
                case 'ease-in-out':
                    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                case 'bounce':
                    const n1 = 7.5625;
                    const d1 = 2.75;
                    if (t < 1 / d1) {
                        return n1 * t * t;
                    } else if (t < 2 / d1) {
                        return n1 * (t -= 1.5 / d1) * t + 0.75;
                    } else if (t < 2.5 / d1) {
                        return n1 * (t -= 2.25 / d1) * t + 0.9375;
                    } else {
                        return n1 * (t -= 2.625 / d1) * t + 0.984375;
                    }
                default:
                    return t;
            }
        }

        function animateTextDissolve() {
            return new Promise((resolve) => {
                const startTime = performance.now();
                const duration = totalAnimationDuration * 0.10; // 10% of total duration - completes just before pullback ends
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const alpha = 1 - progress;
                    messageInput.style.color = `rgba(0, 0, 0, ${alpha})`;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Clear input and reset opacity immediately when fade completes
                        messageInput.value = '';
                        messageInput.style.color = 'rgba(0, 0, 0, 1)';
                        messageInput.focus();
                        resolve();
                    }
                }
                
                requestAnimationFrame(animate);
            });
        }

        function animateTextProjectile(messageText) {
            return new Promise((resolve) => {
                const projectile = document.createElement('div');
                projectile.className = 'message-projectile';
                projectile.textContent = messageText;
                
                const inputRect = inputContainer.getBoundingClientRect();
                projectile.style.position = 'fixed';
                projectile.style.left = (inputRect.left + 20) + 'px';
                // Position at top edge of input box (accounting for border)
                projectile.style.top = (inputRect.top + 2) + 'px';
                projectile.style.width = (inputRect.width - 40) + 'px';
                
                document.body.appendChild(projectile);
                
                const lineHeight = parseFloat(getComputedStyle(projectile).lineHeight) || 22;
                const strokeDistance = lineHeight * 2; // ~44px for 2 line heights
                
                const startTime = performance.now();
                const duration = totalAnimationDuration * 0.5; // 50% of total duration
                const launchStart = totalAnimationDuration * 0.18; // 18% into total duration
                
                projectile.style.opacity = '0';
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    let distance = 0;
                    let opacity = 0;
                    
                    if (elapsed < launchStart) {
                        // Hidden during pullback - stay bonded to top edge
                        distance = 0;
                        opacity = 0;
                    } else {
                        const activeElapsed = elapsed - launchStart;
                        const activeDuration = duration - launchStart;
                        const activeProgress = Math.min(activeElapsed / activeDuration, 1);
                        
                        // Smooth continuous easing curve for the entire motion
                        // Using a single easing function to eliminate steps
                        const t = activeProgress;
                        // Custom easing: fast start, gradual deceleration
                        const eased = 1 - Math.pow(1 - t, 2.5);
                        distance = eased * strokeDistance;
                        
                        // Smooth opacity transition synced with motion
                        // Immediate fade throughout the entire motion
                        opacity = 1 - activeProgress;
                    }
                    
                    projectile.style.transform = `translateY(-${distance}px)`;
                    projectile.style.opacity = opacity;
                    
                    // Store position for debug
                    projectile._debugPos = -distance;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        if (projectile.parentNode) {
                            projectile.parentNode.removeChild(projectile);
                        }
                        resolve();
                    }
                }
                
                requestAnimationFrame(animate);
                return projectile;
            });
        }

        function animatePlunger(messageText) {
            return new Promise((resolve) => {
                const startTime = performance.now();
                
                // Timing breakpoints as percentages of total duration
                const pullbackEnd = 0.12;   // 12% - Slow pullback
                const launchEnd = 0.40;     // 40% - Longer launch phase
                const returnEnd = 0.55;     // 55% - Quick return
                const overshootEnd = 0.60;  // 60% - Overshoot past origin
                const settleEnd = 0.65;     // 65% - Settle back to origin
                
                let projectileElement = null;
                const textProjectilePromise = animateTextProjectile(messageText).then(el => {
                    projectileElement = el;
                    return el;
                });
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / totalAnimationDuration, 1);
                    
                    let position = 0;
                    let phase = '';
                    
                    if (progress <= pullbackEnd) {
                        // Pullback phase - slow and steady
                        phase = 'Pullback';
                        const phaseProgress = progress / pullbackEnd;
                        const eased = 1 - Math.pow(1 - phaseProgress, 2);
                        position = eased * pullbackDistance;
                        
                    } else if (progress <= launchEnd) {
                        // Launch phase - explosive acceleration
                        phase = 'Launch';
                        const phaseProgress = (progress - pullbackEnd) / (launchEnd - pullbackEnd);
                        // More aggressive exponential curve for spring release
                        const eased = 1 - Math.exp(-8 * phaseProgress);
                        position = pullbackDistance + eased * (launchDistance - pullbackDistance);
                        
                    } else if (progress <= returnEnd) {
                        // Return phase - using selected easing
                        phase = 'Return';
                        const phaseProgress = (progress - launchEnd) / (returnEnd - launchEnd);
                        const eased = getReturnEasing(phaseProgress);
                        position = launchDistance + eased * (0 - launchDistance);
                    } else if (progress <= overshootEnd) {
                        // Overshoot phase - go 1px past origin
                        phase = 'Overshoot';
                        const phaseProgress = (progress - returnEnd) / (overshootEnd - returnEnd);
                        const eased = Math.sin(phaseProgress * Math.PI / 2); // Smooth curve to overshoot
                        position = eased * 1; // Overshoot by 1px
                    } else if (progress <= settleEnd) {
                        // Settle phase - return from overshoot to origin
                        phase = 'Settle';
                        const phaseProgress = (progress - overshootEnd) / (settleEnd - overshootEnd);
                        const eased = 1 - Math.pow(1 - phaseProgress, 2); // Smooth settle
                        position = 1 - eased; // From 1px back to 0
                    } else {
                        // Rest
                        phase = 'Complete';
                        position = 0;
                    }
                    
                    inputContainer.style.transform = `translateY(${position}px)`;
                    
                    // Debug update
                    const textPos = projectileElement?._debugPos || 0;
                    updateDebug(position, textPos, phase);
                    
                    if (progress < settleEnd) {
                        requestAnimationFrame(animate);
                    } else {
                        inputContainer.style.transform = '';
                        updateDebug(0, 0, 'Complete');
                        // Wait for text projectile to finish if needed
                        if (progress >= 1) {
                            textProjectilePromise.then(resolve);
                        } else {
                            // Continue animation until total duration is reached
                            requestAnimationFrame(animate);
                        }
                    }
                }
                
                requestAnimationFrame(animate);
            });
        }

        async function sendMessage() {
            const messageText = messageInput.value.trim();
            if (!messageText) return;

            sendButton.disabled = true;
            
            // Start text dissolve and plunger animation simultaneously
            inputContainer.classList.add('firing');
            
            // Run both animations in parallel
            const animationPromise = animatePlunger(messageText);
            const fadePromise = (async () => {
                // Start fade immediately at the beginning
                await animateTextDissolve();
            })();
            
            // Wait for both to complete
            await Promise.all([animationPromise, fadePromise]);
            
            inputContainer.classList.remove('firing');
            inputContainer.style.transform = '';
            sendButton.disabled = false;
            messageInput.focus();
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        messageInput.focus();
    </script>
</body>
</html>